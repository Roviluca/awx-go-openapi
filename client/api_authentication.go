/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AuthenticationApiService AuthenticationApi service
type AuthenticationApiService service

type ApiAuthenticationApplicationsActivityStreamListRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiAuthenticationApplicationsActivityStreamListRequest) Page(page int32) ApiAuthenticationApplicationsActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiAuthenticationApplicationsActivityStreamListRequest) PageSize(pageSize int32) ApiAuthenticationApplicationsActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAuthenticationApplicationsActivityStreamListRequest) Search(search string) ApiAuthenticationApplicationsActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiAuthenticationApplicationsActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsActivityStreamListExecute(r)
}

/*
 * AuthenticationApplicationsActivityStreamList  List Activity Streams for an Application
 * 
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
application.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.  

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsActivityStreamListRequest
 */
func (a *AuthenticationApiService) AuthenticationApplicationsActivityStreamList(ctx _context.Context, id string) ApiAuthenticationApplicationsActivityStreamListRequest {
	return ApiAuthenticationApplicationsActivityStreamListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsActivityStreamListExecute(r ApiAuthenticationApplicationsActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsCreate0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	data *map[string]interface{}
}

func (r ApiAuthenticationApplicationsCreate0Request) Data(data map[string]interface{}) ApiAuthenticationApplicationsCreate0Request {
	r.data = &data
	return r
}

func (r ApiAuthenticationApplicationsCreate0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsCreate0Execute(r)
}

/*
 * AuthenticationApplicationsCreate0  Create an Application
 * 
Make a POST request to this resource with the following application
fields to create a new application:









* `name`: Name of this application. (string, required)
* `description`: Optional description of this application. (string, default=`""`)


* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice, required)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string, default=`""`)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice, required)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean, default=`False`)
* `organization`: Organization containing this application. (id, required)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthenticationApplicationsCreate0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsCreate0(ctx _context.Context) ApiAuthenticationApplicationsCreate0Request {
	return ApiAuthenticationApplicationsCreate0Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsCreate0Execute(r ApiAuthenticationApplicationsCreate0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsCreate0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsDelete0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
}

func (r ApiAuthenticationApplicationsDelete0Request) Search(search string) ApiAuthenticationApplicationsDelete0Request {
	r.search = &search
	return r
}

func (r ApiAuthenticationApplicationsDelete0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsDelete0Execute(r)
}

/*
 * AuthenticationApplicationsDelete0  Delete an Application
 * 
Make a DELETE request to this resource to delete this application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsDelete0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsDelete0(ctx _context.Context, id string) ApiAuthenticationApplicationsDelete0Request {
	return ApiAuthenticationApplicationsDelete0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsDelete0Execute(r ApiAuthenticationApplicationsDelete0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsDelete0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsList0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	page *int32
	pageSize *int32
	search *string
}

func (r ApiAuthenticationApplicationsList0Request) Page(page int32) ApiAuthenticationApplicationsList0Request {
	r.page = &page
	return r
}
func (r ApiAuthenticationApplicationsList0Request) PageSize(pageSize int32) ApiAuthenticationApplicationsList0Request {
	r.pageSize = &pageSize
	return r
}
func (r ApiAuthenticationApplicationsList0Request) Search(search string) ApiAuthenticationApplicationsList0Request {
	r.search = &search
	return r
}

func (r ApiAuthenticationApplicationsList0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsList0Execute(r)
}

/*
 * AuthenticationApplicationsList0  List Applications
 * 
Make a GET request to this resource to retrieve the list of
applications.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of applications
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more application records.  

## Results

Each application data structure includes the following fields:

* `id`: Database ID for this application. (integer)
* `type`: Data type for this application. (choice)
* `url`: URL for this application. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this application was created. (datetime)
* `modified`: Timestamp when this application was last modified. (datetime)
* `name`: Name of this application. (string)
* `description`: Optional description of this application. (string)
* `client_id`:  (string)
* `client_secret`: Used for more stringent verification of access to an application when creating a token. (string)
* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean)
* `organization`: Organization containing this application. (id)



## Sorting

To specify that applications are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthenticationApplicationsList0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsList0(ctx _context.Context) ApiAuthenticationApplicationsList0Request {
	return ApiAuthenticationApplicationsList0Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsList0Execute(r ApiAuthenticationApplicationsList0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsList0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsPartialUpdate0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
	data *map[string]interface{}
}

func (r ApiAuthenticationApplicationsPartialUpdate0Request) Search(search string) ApiAuthenticationApplicationsPartialUpdate0Request {
	r.search = &search
	return r
}
func (r ApiAuthenticationApplicationsPartialUpdate0Request) Data(data map[string]interface{}) ApiAuthenticationApplicationsPartialUpdate0Request {
	r.data = &data
	return r
}

func (r ApiAuthenticationApplicationsPartialUpdate0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsPartialUpdate0Execute(r)
}

/*
 * AuthenticationApplicationsPartialUpdate0  Update an Application
 * 
Make a PUT or PATCH request to this resource to update this
application.  The following fields may be modified:









* `name`: Name of this application. (string, required)
* `description`: Optional description of this application. (string, default=`""`)


* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice, required)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string, default=`""`)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice, required)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean, default=`False`)
* `organization`: Organization containing this application. (id, required)








For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsPartialUpdate0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsPartialUpdate0(ctx _context.Context, id string) ApiAuthenticationApplicationsPartialUpdate0Request {
	return ApiAuthenticationApplicationsPartialUpdate0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsPartialUpdate0Execute(r ApiAuthenticationApplicationsPartialUpdate0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsPartialUpdate0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsRead0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
}

func (r ApiAuthenticationApplicationsRead0Request) Search(search string) ApiAuthenticationApplicationsRead0Request {
	r.search = &search
	return r
}

func (r ApiAuthenticationApplicationsRead0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsRead0Execute(r)
}

/*
 * AuthenticationApplicationsRead0  Retrieve an Application
 * 
Make GET request to this resource to retrieve a single application
record containing the following fields:

* `id`: Database ID for this application. (integer)
* `type`: Data type for this application. (choice)
* `url`: URL for this application. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this application was created. (datetime)
* `modified`: Timestamp when this application was last modified. (datetime)
* `name`: Name of this application. (string)
* `description`: Optional description of this application. (string)
* `client_id`:  (string)
* `client_secret`: Used for more stringent verification of access to an application when creating a token. (string)
* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean)
* `organization`: Organization containing this application. (id)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsRead0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsRead0(ctx _context.Context, id string) ApiAuthenticationApplicationsRead0Request {
	return ApiAuthenticationApplicationsRead0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsRead0Execute(r ApiAuthenticationApplicationsRead0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsRead0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsTokensCreate0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	data *map[string]interface{}
}

func (r ApiAuthenticationApplicationsTokensCreate0Request) Data(data map[string]interface{}) ApiAuthenticationApplicationsTokensCreate0Request {
	r.data = &data
	return r
}

func (r ApiAuthenticationApplicationsTokensCreate0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsTokensCreate0Execute(r)
}

/*
 * AuthenticationApplicationsTokensCreate0  Create an Access Token for an Application
 * 
Make a POST request to this resource with the following access token
fields to create a new access token associated with this
application.









* `description`: Optional description of this access token. (string, default=`""`)





* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string, default=`"write"`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsTokensCreate0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsTokensCreate0(ctx _context.Context, id string) ApiAuthenticationApplicationsTokensCreate0Request {
	return ApiAuthenticationApplicationsTokensCreate0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsTokensCreate0Execute(r ApiAuthenticationApplicationsTokensCreate0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsTokensCreate0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/tokens/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsTokensList0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiAuthenticationApplicationsTokensList0Request) Page(page int32) ApiAuthenticationApplicationsTokensList0Request {
	r.page = &page
	return r
}
func (r ApiAuthenticationApplicationsTokensList0Request) PageSize(pageSize int32) ApiAuthenticationApplicationsTokensList0Request {
	r.pageSize = &pageSize
	return r
}
func (r ApiAuthenticationApplicationsTokensList0Request) Search(search string) ApiAuthenticationApplicationsTokensList0Request {
	r.search = &search
	return r
}

func (r ApiAuthenticationApplicationsTokensList0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsTokensList0Execute(r)
}

/*
 * AuthenticationApplicationsTokensList0  List Access Tokens for an Application
 * 
Make a GET request to this resource to retrieve a list of
access tokens associated with the selected
application.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of access tokens
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more access token records.  

## Results

Each access token data structure includes the following fields:

* `id`: Database ID for this access token. (integer)
* `type`: Data type for this access token. (choice)
* `url`: URL for this access token. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this access token was created. (datetime)
* `modified`: Timestamp when this access token was last modified. (datetime)
* `description`: Optional description of this access token. (string)
* `user`: The user representing the token owner (id)
* `token`:  (string)
* `refresh_token`:  (field)
* `application`:  (id)
* `expires`:  (datetime)
* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string)



## Sorting

To specify that access tokens are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsTokensList0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsTokensList0(ctx _context.Context, id string) ApiAuthenticationApplicationsTokensList0Request {
	return ApiAuthenticationApplicationsTokensList0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsTokensList0Execute(r ApiAuthenticationApplicationsTokensList0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsTokensList0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/tokens/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationApplicationsUpdate0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
	data *InlineObject
}

func (r ApiAuthenticationApplicationsUpdate0Request) Search(search string) ApiAuthenticationApplicationsUpdate0Request {
	r.search = &search
	return r
}
func (r ApiAuthenticationApplicationsUpdate0Request) Data(data InlineObject) ApiAuthenticationApplicationsUpdate0Request {
	r.data = &data
	return r
}

func (r ApiAuthenticationApplicationsUpdate0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationApplicationsUpdate0Execute(r)
}

/*
 * AuthenticationApplicationsUpdate0  Update an Application
 * 
Make a PUT or PATCH request to this resource to update this
application.  The following fields may be modified:









* `name`: Name of this application. (string, required)
* `description`: Optional description of this application. (string, default=`""`)


* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice, required)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string, default=`""`)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice, required)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean, default=`False`)
* `organization`: Organization containing this application. (id, required)






For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationApplicationsUpdate0Request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsUpdate0(ctx _context.Context, id string) ApiAuthenticationApplicationsUpdate0Request {
	return ApiAuthenticationApplicationsUpdate0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationApplicationsUpdate0Execute(r ApiAuthenticationApplicationsUpdate0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationApplicationsUpdate0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationOListRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
}


func (r ApiAuthenticationOListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationOListExecute(r)
}

/*
 * AuthenticationOList  Token Handling using OAuth2
 * 
This page lists OAuth 2 utility endpoints used for authorization, token refresh and revoke.
Note endpoints other than `/api/o/authorize/` are not meant to be used in browsers and do not
support HTTP GET. The endpoints here strictly follow
[RFC specs for OAuth2](https://tools.ietf.org/html/rfc6749), so please use that for detailed
reference. Note AWX net location default to `http://localhost:8013` in examples:


## Create Token for an Application using Authorization code grant type
Given an application "AuthCodeApp" of grant type `authorization-code`, 
from the client app, the user makes a GET to the Authorize endpoint with 

* `response_type`
* `client_id`
* `redirect_uris`
* `scope`  

AWX will respond with the authorization `code` and `state`
to the redirect_uri specified in the application. The client application will then make a POST to the
`api/o/token/` endpoint on AWX with

* `code`
* `client_id`
* `client_secret`
* `grant_type`
* `redirect_uri`

AWX will respond with the `access_token`, `token_type`, `refresh_token`, and `expires_in`. For more
information on testing this flow, refer to [django-oauth-toolkit](http://django-oauth-toolkit.readthedocs.io/en/latest/tutorial/tutorial_01.html#test-your-authorization-server).


## Create Token for an Application using Password grant type

Log in is not required for `password` grant type, so a simple `curl` can be used to acquire a personal access token
via `/api/o/token/` with 

* `grant_type`: Required to be "password"
* `username`
* `password`
* `client_id`: Associated application must have grant_type "password"
* `client_secret`

For example:

```bash
curl -X POST \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=password&username=<username>&password=<password>&scope=read" \
  -u "gwSPoasWSdNkMDtBN3Hu2WYQpPWCO9SwUEsKK22l:fI6ZpfocHYBGfm1tP92r0yIgCyfRdDQt0Tos9L8a4fNsJjQQMwp9569e
IaUBsaVDgt2eiwOGe0bg5m5vCSstClZmtdy359RVx2rQK5YlIWyPlrolpt2LEpVeKXWaiybo" \
  http://localhost:8013/api/o/token/ -i
```
In the above post request, parameters `username` and `password` are username and password of the related
AWX user of the underlying application, and the authentication information is of format
`<client_id>:<client_secret>`, where `client_id` and `client_secret` are the corresponding fields of
underlying application.

Upon success, access token, refresh token and other information are given in the response body in JSON
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthenticationOListRequest
 */
func (a *AuthenticationApiService) AuthenticationOList(ctx _context.Context) ApiAuthenticationOListRequest {
	return ApiAuthenticationOListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationOListExecute(r ApiAuthenticationOListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationOList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/o/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensActivityStreamListRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiAuthenticationTokensActivityStreamListRequest) Page(page int32) ApiAuthenticationTokensActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiAuthenticationTokensActivityStreamListRequest) PageSize(pageSize int32) ApiAuthenticationTokensActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAuthenticationTokensActivityStreamListRequest) Search(search string) ApiAuthenticationTokensActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiAuthenticationTokensActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensActivityStreamListExecute(r)
}

/*
 * AuthenticationTokensActivityStreamList  List Activity Streams for an Access Token
 * 
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
access token.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.  

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationTokensActivityStreamListRequest
 */
func (a *AuthenticationApiService) AuthenticationTokensActivityStreamList(ctx _context.Context, id string) ApiAuthenticationTokensActivityStreamListRequest {
	return ApiAuthenticationTokensActivityStreamListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensActivityStreamListExecute(r ApiAuthenticationTokensActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensCreate0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	data *map[string]interface{}
}

func (r ApiAuthenticationTokensCreate0Request) Data(data map[string]interface{}) ApiAuthenticationTokensCreate0Request {
	r.data = &data
	return r
}

func (r ApiAuthenticationTokensCreate0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensCreate0Execute(r)
}

/*
 * AuthenticationTokensCreate0  Create an Access Token
 * 
Make a POST request to this resource with the following access token
fields to create a new access token:









* `description`: Optional description of this access token. (string, default=`""`)



* `application`:  (id, default=``)

* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string, default=`"write"`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthenticationTokensCreate0Request
 */
func (a *AuthenticationApiService) AuthenticationTokensCreate0(ctx _context.Context) ApiAuthenticationTokensCreate0Request {
	return ApiAuthenticationTokensCreate0Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensCreate0Execute(r ApiAuthenticationTokensCreate0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensCreate0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensDeleteRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
}

func (r ApiAuthenticationTokensDeleteRequest) Search(search string) ApiAuthenticationTokensDeleteRequest {
	r.search = &search
	return r
}

func (r ApiAuthenticationTokensDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensDeleteExecute(r)
}

/*
 * AuthenticationTokensDelete  Delete an Access Token
 * 
Make a DELETE request to this resource to delete this access token.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationTokensDeleteRequest
 */
func (a *AuthenticationApiService) AuthenticationTokensDelete(ctx _context.Context, id string) ApiAuthenticationTokensDeleteRequest {
	return ApiAuthenticationTokensDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensDeleteExecute(r ApiAuthenticationTokensDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensList0Request struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	page *int32
	pageSize *int32
	search *string
}

func (r ApiAuthenticationTokensList0Request) Page(page int32) ApiAuthenticationTokensList0Request {
	r.page = &page
	return r
}
func (r ApiAuthenticationTokensList0Request) PageSize(pageSize int32) ApiAuthenticationTokensList0Request {
	r.pageSize = &pageSize
	return r
}
func (r ApiAuthenticationTokensList0Request) Search(search string) ApiAuthenticationTokensList0Request {
	r.search = &search
	return r
}

func (r ApiAuthenticationTokensList0Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensList0Execute(r)
}

/*
 * AuthenticationTokensList0  List Access Tokens
 * 
Make a GET request to this resource to retrieve the list of
access tokens.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of access tokens
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more access token records.  

## Results

Each access token data structure includes the following fields:

* `id`: Database ID for this access token. (integer)
* `type`: Data type for this access token. (choice)
* `url`: URL for this access token. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this access token was created. (datetime)
* `modified`: Timestamp when this access token was last modified. (datetime)
* `description`: Optional description of this access token. (string)
* `user`: The user representing the token owner (id)
* `token`:  (string)
* `refresh_token`:  (field)
* `application`:  (id)
* `expires`:  (datetime)
* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string)



## Sorting

To specify that access tokens are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthenticationTokensList0Request
 */
func (a *AuthenticationApiService) AuthenticationTokensList0(ctx _context.Context) ApiAuthenticationTokensList0Request {
	return ApiAuthenticationTokensList0Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensList0Execute(r ApiAuthenticationTokensList0Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensList0")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
	data *map[string]interface{}
}

func (r ApiAuthenticationTokensPartialUpdateRequest) Search(search string) ApiAuthenticationTokensPartialUpdateRequest {
	r.search = &search
	return r
}
func (r ApiAuthenticationTokensPartialUpdateRequest) Data(data map[string]interface{}) ApiAuthenticationTokensPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiAuthenticationTokensPartialUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensPartialUpdateExecute(r)
}

/*
 * AuthenticationTokensPartialUpdate  Update an Access Token
 * 
Make a PUT or PATCH request to this resource to update this
access token.  The following fields may be modified:









* `description`: Optional description of this access token. (string, default=`""`)





* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string, default=`"write"`)








For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationTokensPartialUpdateRequest
 */
func (a *AuthenticationApiService) AuthenticationTokensPartialUpdate(ctx _context.Context, id string) ApiAuthenticationTokensPartialUpdateRequest {
	return ApiAuthenticationTokensPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensPartialUpdateExecute(r ApiAuthenticationTokensPartialUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensPartialUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensReadRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
}

func (r ApiAuthenticationTokensReadRequest) Search(search string) ApiAuthenticationTokensReadRequest {
	r.search = &search
	return r
}

func (r ApiAuthenticationTokensReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensReadExecute(r)
}

/*
 * AuthenticationTokensRead  Retrieve an Access Token
 * 
Make GET request to this resource to retrieve a single access token
record containing the following fields:

* `id`: Database ID for this access token. (integer)
* `type`: Data type for this access token. (choice)
* `url`: URL for this access token. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this access token was created. (datetime)
* `modified`: Timestamp when this access token was last modified. (datetime)
* `description`: Optional description of this access token. (string)
* `user`: The user representing the token owner (id)
* `token`:  (string)
* `refresh_token`:  (field)
* `application`:  (id)
* `expires`:  (datetime)
* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationTokensReadRequest
 */
func (a *AuthenticationApiService) AuthenticationTokensRead(ctx _context.Context, id string) ApiAuthenticationTokensReadRequest {
	return ApiAuthenticationTokensReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensReadExecute(r ApiAuthenticationTokensReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthenticationTokensUpdateRequest struct {
	ctx _context.Context
	ApiService *AuthenticationApiService
	id string
	search *string
	data *InlineObject68
}

func (r ApiAuthenticationTokensUpdateRequest) Search(search string) ApiAuthenticationTokensUpdateRequest {
	r.search = &search
	return r
}
func (r ApiAuthenticationTokensUpdateRequest) Data(data InlineObject68) ApiAuthenticationTokensUpdateRequest {
	r.data = &data
	return r
}

func (r ApiAuthenticationTokensUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthenticationTokensUpdateExecute(r)
}

/*
 * AuthenticationTokensUpdate  Update an Access Token
 * 
Make a PUT or PATCH request to this resource to update this
access token.  The following fields may be modified:









* `description`: Optional description of this access token. (string, default=`""`)





* `scope`: Allowed scopes, further restricts user&#39;s permissions. Must be a simple space-separated string with allowed scopes [&#39;read&#39;, &#39;write&#39;]. (string, default=`"write"`)






For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAuthenticationTokensUpdateRequest
 */
func (a *AuthenticationApiService) AuthenticationTokensUpdate(ctx _context.Context, id string) ApiAuthenticationTokensUpdateRequest {
	return ApiAuthenticationTokensUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthenticationApiService) AuthenticationTokensUpdateExecute(r ApiAuthenticationTokensUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationApiService.AuthenticationTokensUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
