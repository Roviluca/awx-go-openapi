/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version:
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AdHocCommandsApiService AdHocCommandsApi service
type AdHocCommandsApiService service

type ApiAdHocCommandsAdHocCommandsActivityStreamListRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsActivityStreamListRequest) Page(page int32) ApiAdHocCommandsAdHocCommandsActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiAdHocCommandsAdHocCommandsActivityStreamListRequest) PageSize(pageSize int32) ApiAdHocCommandsAdHocCommandsActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAdHocCommandsAdHocCommandsActivityStreamListRequest) Search(search string) ApiAdHocCommandsAdHocCommandsActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsActivityStreamListExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsActivityStreamList  List Activity Streams for an Ad Hoc Command
 *
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
ad hoc command.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsActivityStreamListRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsActivityStreamList(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsActivityStreamListRequest {
	return ApiAdHocCommandsAdHocCommandsActivityStreamListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsActivityStreamListExecute(r ApiAdHocCommandsAdHocCommandsActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsCancelCreateRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
}

func (r ApiAdHocCommandsAdHocCommandsCancelCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsCancelCreateExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsCancelCreate  Retrieve an Ad Hoc Command
 *
Make GET request to this resource to retrieve a single ad hoc command
record containing the following fields:

* `can_cancel`:  (boolean)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsCancelCreateRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCancelCreate(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsCancelCreateRequest {
	return ApiAdHocCommandsAdHocCommandsCancelCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCancelCreateExecute(r ApiAdHocCommandsAdHocCommandsCancelCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsCancelCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsCancelReadRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsCancelReadRequest) Search(search string) ApiAdHocCommandsAdHocCommandsCancelReadRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsCancelReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsCancelReadExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsCancelRead  Retrieve an Ad Hoc Command
 *
Make GET request to this resource to retrieve a single ad hoc command
record containing the following fields:

* `can_cancel`:  (boolean)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsCancelReadRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCancelRead(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsCancelReadRequest {
	return ApiAdHocCommandsAdHocCommandsCancelReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCancelReadExecute(r ApiAdHocCommandsAdHocCommandsCancelReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsCancelRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsCreateRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	data       *map[string]interface{}
}

func (r ApiAdHocCommandsAdHocCommandsCreateRequest) Data(data map[string]interface{}) ApiAdHocCommandsAdHocCommandsCreateRequest {
	r.data = &data
	return r
}

func (r ApiAdHocCommandsAdHocCommandsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsCreateExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsCreate  Create an Ad Hoc Command
 *
Make a POST request to this resource with the following ad hoc command
fields to create a new ad hoc command:




















* `job_type`:  (choice)
    - `run`: Run (default)
    - `check`: Check
* `inventory`:  (id, default=``)
* `limit`:  (string, default=`""`)
* `credential`:  (id, default=``)
* `module_name`:  (choice)
    - `command` (default)
    - `shell`
    - `yum`
    - `apt`
    - `apt_key`
    - `apt_repository`
    - `apt_rpm`
    - `service`
    - `group`
    - `user`
    - `mount`
    - `ping`
    - `selinux`
    - `setup`
    - `win_ping`
    - `win_service`
    - `win_updates`
    - `win_group`
    - `win_user`
* `module_args`:  (string, default=`""`)
* `forks`:  (integer, default=`0`)
* `verbosity`:  (choice)
    - `0`: 0 (Normal) (default)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (string, default=`""`)
* `become_enabled`:  (boolean, default=`False`)
* `diff_mode`:  (boolean, default=`False`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAdHocCommandsAdHocCommandsCreateRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCreate(ctx _context.Context) ApiAdHocCommandsAdHocCommandsCreateRequest {
	return ApiAdHocCommandsAdHocCommandsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsCreateExecute(r ApiAdHocCommandsAdHocCommandsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsDeleteRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsDeleteRequest) Search(search string) ApiAdHocCommandsAdHocCommandsDeleteRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsDeleteExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsDelete  Delete an Ad Hoc Command
 *
Make a DELETE request to this resource to delete this ad hoc command.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsDeleteRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsDelete(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsDeleteRequest {
	return ApiAdHocCommandsAdHocCommandsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsDeleteExecute(r ApiAdHocCommandsAdHocCommandsDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsEventsListRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsEventsListRequest) Page(page int32) ApiAdHocCommandsAdHocCommandsEventsListRequest {
	r.page = &page
	return r
}
func (r ApiAdHocCommandsAdHocCommandsEventsListRequest) PageSize(pageSize int32) ApiAdHocCommandsAdHocCommandsEventsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAdHocCommandsAdHocCommandsEventsListRequest) Search(search string) ApiAdHocCommandsAdHocCommandsEventsListRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsEventsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsEventsListExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsEventsList  List Ad Hoc Command Events for an Ad Hoc Command
 *
Make a GET request to this resource to retrieve a list of
ad hoc command events associated with the selected
ad hoc command.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of ad hoc command events
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more ad hoc command event records.

## Results

Each ad hoc command event data structure includes the following fields:

* `id`: Database ID for this ad hoc command event. (integer)
* `type`: Data type for this ad hoc command event. (choice)
* `url`: URL for this ad hoc command event. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this ad hoc command event was created. (datetime)
* `modified`: Timestamp when this ad hoc command event was last modified. (datetime)
* `ad_hoc_command`:  (id)
* `event`:  (choice)
    - `runner_on_failed`: Host Failed
    - `runner_on_ok`: Host OK
    - `runner_on_unreachable`: Host Unreachable
    - `runner_on_skipped`: Host Skipped
    - `debug`: Debug
    - `verbose`: Verbose
    - `deprecated`: Deprecated
    - `warning`: Warning
    - `system_warning`: System Warning
    - `error`: Error
* `counter`:  (integer)
* `event_display`:  (string)
* `event_data`:  (json)
* `failed`:  (boolean)
* `changed`:  (boolean)
* `uuid`:  (string)
* `host`:  (id)
* `host_name`:  (string)
* `stdout`:  (string)
* `start_line`:  (integer)
* `end_line`:  (integer)
* `verbosity`:  (integer)



## Sorting

To specify that ad hoc command events are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsEventsListRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsEventsList(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsEventsListRequest {
	return ApiAdHocCommandsAdHocCommandsEventsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsEventsListExecute(r ApiAdHocCommandsAdHocCommandsEventsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsEventsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/events/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsListRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsListRequest) Page(page int32) ApiAdHocCommandsAdHocCommandsListRequest {
	r.page = &page
	return r
}
func (r ApiAdHocCommandsAdHocCommandsListRequest) PageSize(pageSize int32) ApiAdHocCommandsAdHocCommandsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAdHocCommandsAdHocCommandsListRequest) Search(search string) ApiAdHocCommandsAdHocCommandsListRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsListExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsList  List Ad Hoc Commands
 *
Make a GET request to this resource to retrieve the list of
ad hoc commands.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of ad hoc commands
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more ad hoc command records.

## Results

Each ad hoc command data structure includes the following fields:

* `id`: Database ID for this ad hoc command. (integer)
* `type`: Data type for this ad hoc command. (choice)
* `url`: URL for this ad hoc command. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this ad hoc command was created. (datetime)
* `modified`: Timestamp when this ad hoc command was last modified. (datetime)
* `name`: Name of this ad hoc command. (string)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `execution_node`: The node the job executed on. (string)
* `controller_node`: The instance that managed the isolated execution environment. (string)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
* `inventory`:  (id)
* `limit`:  (string)
* `credential`:  (id)
* `module_name`:  (choice)
    - `command`
    - `shell`
    - `yum`
    - `apt`
    - `apt_key`
    - `apt_repository`
    - `apt_rpm`
    - `service`
    - `group`
    - `user`
    - `mount`
    - `ping`
    - `selinux`
    - `setup`
    - `win_ping`
    - `win_service`
    - `win_updates`
    - `win_group`
    - `win_user`
* `module_args`:  (string)
* `forks`:  (integer)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (string)
* `become_enabled`:  (boolean)
* `diff_mode`:  (boolean)



## Sorting

To specify that ad hoc commands are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAdHocCommandsAdHocCommandsListRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsList(ctx _context.Context) ApiAdHocCommandsAdHocCommandsListRequest {
	return ApiAdHocCommandsAdHocCommandsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsListExecute(r ApiAdHocCommandsAdHocCommandsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsNotificationsListRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsNotificationsListRequest) Page(page int32) ApiAdHocCommandsAdHocCommandsNotificationsListRequest {
	r.page = &page
	return r
}
func (r ApiAdHocCommandsAdHocCommandsNotificationsListRequest) PageSize(pageSize int32) ApiAdHocCommandsAdHocCommandsNotificationsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAdHocCommandsAdHocCommandsNotificationsListRequest) Search(search string) ApiAdHocCommandsAdHocCommandsNotificationsListRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsNotificationsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsNotificationsListExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsNotificationsList  List Notifications for an Ad Hoc Command
 *
Make a GET request to this resource to retrieve a list of
notifications associated with the selected
ad hoc command.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notifications
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification records.

## Results

Each notification data structure includes the following fields:

* `id`: Database ID for this notification. (integer)
* `type`: Data type for this notification. (choice)
* `url`: URL for this notification. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification was created. (datetime)
* `modified`: Timestamp when this notification was last modified. (datetime)
* `notification_template`:  (id)
* `error`:  (string)
* `status`:  (choice)
    - `pending`: Pending
    - `successful`: Successful
    - `failed`: Failed
* `notifications_sent`:  (integer)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `recipients`:  (string)
* `subject`:  (string)
* `body`: Notification body (json)



## Sorting

To specify that notifications are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsNotificationsListRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsNotificationsList(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsNotificationsListRequest {
	return ApiAdHocCommandsAdHocCommandsNotificationsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsNotificationsListExecute(r ApiAdHocCommandsAdHocCommandsNotificationsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsNotificationsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/notifications/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsReadRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsReadRequest) Search(search string) ApiAdHocCommandsAdHocCommandsReadRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsReadExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsRead  Retrieve an Ad Hoc Command
 *
Make GET request to this resource to retrieve a single ad hoc command
record containing the following fields:

* `id`: Database ID for this ad hoc command. (integer)
* `type`: Data type for this ad hoc command. (choice)
* `url`: URL for this ad hoc command. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this ad hoc command was created. (datetime)
* `modified`: Timestamp when this ad hoc command was last modified. (datetime)
* `name`: Name of this ad hoc command. (string)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_args`:  (string)
* `job_cwd`:  (string)
* `job_env`:  (json)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `execution_node`: The node the job executed on. (string)
* `controller_node`: The instance that managed the isolated execution environment. (string)
* `result_traceback`:  (string)
* `event_processing_finished`: Indicates whether all of the events generated by this unified job have been saved to the database. (boolean)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
* `inventory`:  (id)
* `limit`:  (string)
* `credential`:  (id)
* `module_name`:  (choice)
    - `command`
    - `shell`
    - `yum`
    - `apt`
    - `apt_key`
    - `apt_repository`
    - `apt_rpm`
    - `service`
    - `group`
    - `user`
    - `mount`
    - `ping`
    - `selinux`
    - `setup`
    - `win_ping`
    - `win_service`
    - `win_updates`
    - `win_group`
    - `win_user`
* `module_args`:  (string)
* `forks`:  (integer)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (string)
* `become_enabled`:  (boolean)
* `diff_mode`:  (boolean)
* `host_status_counts`: A count of hosts uniquely assigned to each status. (field)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsReadRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsRead(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsReadRequest {
	return ApiAdHocCommandsAdHocCommandsReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsReadExecute(r ApiAdHocCommandsAdHocCommandsReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
}

func (r ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsRelaunchCreateExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsRelaunchCreate Relaunch an Ad Hoc Command
 *
Make a POST request to this resource to launch a job. If any passwords or variables are required then they should be passed in via POST data.   In order to determine what values are required in order to launch a job based on this job template you may make a GET request to this endpoint.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsRelaunchCreate(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest {
	return ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsRelaunchCreateExecute(r ApiAdHocCommandsAdHocCommandsRelaunchCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsRelaunchCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/relaunch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsRelaunchListRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiAdHocCommandsAdHocCommandsRelaunchListRequest) Page(page int32) ApiAdHocCommandsAdHocCommandsRelaunchListRequest {
	r.page = &page
	return r
}
func (r ApiAdHocCommandsAdHocCommandsRelaunchListRequest) PageSize(pageSize int32) ApiAdHocCommandsAdHocCommandsRelaunchListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiAdHocCommandsAdHocCommandsRelaunchListRequest) Search(search string) ApiAdHocCommandsAdHocCommandsRelaunchListRequest {
	r.search = &search
	return r
}

func (r ApiAdHocCommandsAdHocCommandsRelaunchListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsRelaunchListExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsRelaunchList Relaunch an Ad Hoc Command
 *
Make a POST request to this resource to launch a job. If any passwords or variables are required then they should be passed in via POST data.   In order to determine what values are required in order to launch a job based on this job template you may make a GET request to this endpoint.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsRelaunchListRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsRelaunchList(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsRelaunchListRequest {
	return ApiAdHocCommandsAdHocCommandsRelaunchListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsRelaunchListExecute(r ApiAdHocCommandsAdHocCommandsRelaunchListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsRelaunchList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/relaunch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdHocCommandsAdHocCommandsStdoutReadRequest struct {
	ctx        _context.Context
	ApiService *AdHocCommandsApiService
	id         string
}

func (r ApiAdHocCommandsAdHocCommandsStdoutReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocCommandsAdHocCommandsStdoutReadExecute(r)
}

/*
 * AdHocCommandsAdHocCommandsStdoutRead  Retrieve Ad Hoc Command Stdout
 *
Make GET request to this resource to retrieve the stdout from running this
ad hoc command.

## Format

Use the `format` query string parameter to specify the output format.

* Browsable API: `?format=api`
* HTML: `?format=html`
* Plain Text: `?format=txt`
* Plain Text with ANSI color codes: `?format=ansi`
* JSON structure: `?format=json`
* Downloaded Plain Text: `?format=txt_download`
* Downloaded Plain Text with ANSI color codes: `?format=ansi_download`

(_New in Ansible Tower 2.0.0_) When using the Browsable API, HTML and JSON
formats, the `start_line` and `end_line` query string parameters can be used
to specify a range of line numbers to retrieve.

Use `dark=1` or `dark=0` as a query string parameter to force or disable a
dark background.

Files over 1.0MB (configurable)
will not display in the browser. Use the `txt_download` or `ansi_download`
formats to download the file directly to view it.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiAdHocCommandsAdHocCommandsStdoutReadRequest
*/
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsStdoutRead(ctx _context.Context, id string) ApiAdHocCommandsAdHocCommandsStdoutReadRequest {
	return ApiAdHocCommandsAdHocCommandsStdoutReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *AdHocCommandsApiService) AdHocCommandsAdHocCommandsStdoutReadExecute(r ApiAdHocCommandsAdHocCommandsStdoutReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocCommandsApiService.AdHocCommandsAdHocCommandsStdoutRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ad_hoc_commands/{id}/stdout/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
