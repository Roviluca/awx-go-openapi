/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// WorkflowJobsApiService WorkflowJobsApi service
type WorkflowJobsApiService service

type ApiWorkflowJobsWorkflowJobsActivityStreamListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsActivityStreamListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsActivityStreamListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsActivityStreamListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsActivityStreamListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsActivityStreamList  List Activity Streams for a Workflow Job
 * 
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
workflow job.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.  

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsActivityStreamListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsActivityStreamList(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsActivityStreamListRequest {
	return ApiWorkflowJobsWorkflowJobsActivityStreamListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsActivityStreamListExecute(r ApiWorkflowJobsWorkflowJobsActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsCancelCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
}


func (r ApiWorkflowJobsWorkflowJobsCancelCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsCancelCreateExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsCancelCreate  Cancel Workflow Job
 * 
Make a GET request to this resource to determine if the workflow job can be
canceled. The response will include the following field:

* `can_cancel`: Indicates whether this workflow job is in a state that can
  be canceled (boolean, read-only)

Make a POST request to this endpoint to submit a request to cancel a pending
or running workflow job.  The response status code will be 202 if the
request to cancel was successfully submitted, or 405 if the workflow job
cannot be canceled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsCancelCreateRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsCancelCreate(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsCancelCreateRequest {
	return ApiWorkflowJobsWorkflowJobsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsCancelCreateExecute(r ApiWorkflowJobsWorkflowJobsCancelCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsCancelCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsCancelReadRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsCancelReadRequest) Search(search string) ApiWorkflowJobsWorkflowJobsCancelReadRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsCancelReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsCancelReadExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsCancelRead  Cancel Workflow Job
 * 
Make a GET request to this resource to determine if the workflow job can be
canceled. The response will include the following field:

* `can_cancel`: Indicates whether this workflow job is in a state that can
  be canceled (boolean, read-only)

Make a POST request to this endpoint to submit a request to cancel a pending
or running workflow job.  The response status code will be 202 if the
request to cancel was successfully submitted, or 405 if the workflow job
cannot be canceled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsCancelReadRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsCancelRead(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsCancelReadRequest {
	return ApiWorkflowJobsWorkflowJobsCancelReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsCancelReadExecute(r ApiWorkflowJobsWorkflowJobsCancelReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsCancelRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsDeleteRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsDeleteRequest) Search(search string) ApiWorkflowJobsWorkflowJobsDeleteRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsDeleteExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsDelete  Delete a Workflow Job
 * 
Make a DELETE request to this resource to delete this workflow job.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsDeleteRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsDelete(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsDeleteRequest {
	return ApiWorkflowJobsWorkflowJobsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsDeleteExecute(r ApiWorkflowJobsWorkflowJobsDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsLabelsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsLabelsListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsLabelsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsLabelsListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsLabelsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsLabelsListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsLabelsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsLabelsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsLabelsListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsLabelsList  List Labels for a Workflow Job
 * 
Make a GET request to this resource to retrieve a list of
labels associated with the selected
workflow job.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of labels
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more label records.  

## Results

Each label data structure includes the following fields:

* `id`: Database ID for this label. (integer)
* `type`: Data type for this label. (choice)
* `url`: URL for this label. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this label was created. (datetime)
* `modified`: Timestamp when this label was last modified. (datetime)
* `name`: Name of this label. (string)
* `organization`: Organization this label belongs to. (id)



## Sorting

To specify that labels are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsLabelsListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsLabelsList(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsLabelsListRequest {
	return ApiWorkflowJobsWorkflowJobsLabelsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsLabelsListExecute(r ApiWorkflowJobsWorkflowJobsLabelsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsLabelsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsList  List Workflow Jobs
 * 
Make a GET request to this resource to retrieve the list of
workflow jobs.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow jobs
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job records.  

## Results

Each workflow job data structure includes the following fields:

* `id`: Database ID for this workflow job. (integer)
* `type`: Data type for this workflow job. (choice)
* `url`: URL for this workflow job. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job was created. (datetime)
* `modified`: Timestamp when this workflow job was last modified. (datetime)
* `name`: Name of this workflow job. (string)
* `description`: Optional description of this workflow job. (string)
* `unified_job_template`:  (id)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `workflow_job_template`:  (id)
* `extra_vars`:  (json)
* `allow_simultaneous`:  (boolean)
* `job_template`: If automatically created for a sliced job run, the job template the workflow job was created from. (id)
* `is_sliced_job`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string)



## Sorting

To specify that workflow jobs are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWorkflowJobsWorkflowJobsListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsList(ctx _context.Context) ApiWorkflowJobsWorkflowJobsListRequest {
	return ApiWorkflowJobsWorkflowJobsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsListExecute(r ApiWorkflowJobsWorkflowJobsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsNotificationsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsNotificationsListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsNotificationsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsNotificationsListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsNotificationsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsNotificationsListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsNotificationsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsNotificationsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsNotificationsListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsNotificationsList  List Notifications for a Workflow Job
 * 
Make a GET request to this resource to retrieve a list of
notifications associated with the selected
workflow job.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notifications
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification records.  

## Results

Each notification data structure includes the following fields:

* `id`: Database ID for this notification. (integer)
* `type`: Data type for this notification. (choice)
* `url`: URL for this notification. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification was created. (datetime)
* `modified`: Timestamp when this notification was last modified. (datetime)
* `notification_template`:  (id)
* `error`:  (string)
* `status`:  (choice)
    - `pending`: Pending
    - `successful`: Successful
    - `failed`: Failed
* `notifications_sent`:  (integer)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `recipients`:  (string)
* `subject`:  (string)
* `body`: Notification body (json)



## Sorting

To specify that notifications are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsNotificationsListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsNotificationsList(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsNotificationsListRequest {
	return ApiWorkflowJobsWorkflowJobsNotificationsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsNotificationsListExecute(r ApiWorkflowJobsWorkflowJobsNotificationsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsNotificationsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/notifications/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsReadRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsReadRequest) Search(search string) ApiWorkflowJobsWorkflowJobsReadRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsReadExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsRead  Retrieve a Workflow Job
 * 
Make GET request to this resource to retrieve a single workflow job
record containing the following fields:

* `id`: Database ID for this workflow job. (integer)
* `type`: Data type for this workflow job. (choice)
* `url`: URL for this workflow job. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job was created. (datetime)
* `modified`: Timestamp when this workflow job was last modified. (datetime)
* `name`: Name of this workflow job. (string)
* `description`: Optional description of this workflow job. (string)
* `unified_job_template`:  (id)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_args`:  (string)
* `job_cwd`:  (string)
* `job_env`:  (json)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `result_traceback`:  (string)
* `workflow_job_template`:  (id)
* `extra_vars`:  (json)
* `allow_simultaneous`:  (boolean)
* `job_template`: If automatically created for a sliced job run, the job template the workflow job was created from. (id)
* `is_sliced_job`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsReadRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsRead(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsReadRequest {
	return ApiWorkflowJobsWorkflowJobsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsReadExecute(r ApiWorkflowJobsWorkflowJobsReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
}


func (r ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsRelaunchCreateExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsRelaunchCreate Relaunch a workflow job
 * 
Make a POST request to this endpoint to launch a workflow job identical to the parent workflow job. This will spawn jobs, project updates, or inventory updates based on the unified job templates referenced in the workflow nodes in the workflow job. No POST data is accepted for this action.

If successful, the response status code will be 201 and serialized data of the new workflow job will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsRelaunchCreate(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest {
	return ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsRelaunchCreateExecute(r ApiWorkflowJobsWorkflowJobsRelaunchCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsRelaunchCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/relaunch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsRelaunchListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsRelaunchListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsRelaunchListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsRelaunchListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsRelaunchListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsRelaunchListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsRelaunchListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsRelaunchListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsRelaunchListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsRelaunchList Relaunch a workflow job
 * 
Make a POST request to this endpoint to launch a workflow job identical to the parent workflow job. This will spawn jobs, project updates, or inventory updates based on the unified job templates referenced in the workflow nodes in the workflow job. No POST data is accepted for this action.

If successful, the response status code will be 201 and serialized data of the new workflow job will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsRelaunchListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsRelaunchList(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsRelaunchListRequest {
	return ApiWorkflowJobsWorkflowJobsRelaunchListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsRelaunchListExecute(r ApiWorkflowJobsWorkflowJobsRelaunchListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsRelaunchList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/relaunch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobsApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest) Page(page int32) ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest) PageSize(pageSize int32) ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest) Search(search string) ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobsWorkflowJobsWorkflowNodesListExecute(r)
}

/*
 * WorkflowJobsWorkflowJobsWorkflowNodesList  List Workflow Job Nodes for a Workflow Job
 * 
Make a GET request to this resource to retrieve a list of
workflow job nodes associated with the selected
workflow job.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow job nodes
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job node records.  

## Results

Each workflow job node data structure includes the following fields:

* `id`: Database ID for this workflow job node. (integer)
* `type`: Data type for this workflow job node. (choice)
* `url`: URL for this workflow job node. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job node was created. (datetime)
* `modified`: Timestamp when this workflow job node was last modified. (datetime)
* `extra_data`:  (json)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `scm_branch`:  (string)
* `job_type`:  (choice)
    - `None`: ---------
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string)
* `skip_tags`:  (string)
* `limit`:  (string)
* `diff_mode`:  (boolean)
* `verbosity`:  (choice)
    - `None`: ---------
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `job`:  (id)
* `workflow_job`:  (id)
* `unified_job_template`:  (id)
* `success_nodes`:  (field)
* `failure_nodes`:  (field)
* `always_nodes`:  (field)
* `all_parents_must_converge`: If enabled then the node will only run if all of the parent nodes have met the criteria to reach this node (boolean)
* `do_not_run`: Indicates that a job will not be created when True. Workflow runtime semantics will mark this True if the node is in a path that will decidedly not be ran. A value of False means the node may not run. (boolean)
* `identifier`: An identifier coresponding to the workflow job template node that this node was created from. (string)



## Sorting

To specify that workflow job nodes are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsWorkflowNodesList(ctx _context.Context, id string) ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest {
	return ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobsApiService) WorkflowJobsWorkflowJobsWorkflowNodesListExecute(r ApiWorkflowJobsWorkflowJobsWorkflowNodesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobsApiService.WorkflowJobsWorkflowJobsWorkflowNodesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_jobs/{id}/workflow_nodes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
