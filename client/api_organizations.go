/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version:
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// OrganizationsApiService OrganizationsApi service
type OrganizationsApiService service

type ApiOrganizationsOrganizationsAccessListListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsAccessListListRequest) Page(page int32) ApiOrganizationsOrganizationsAccessListListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsAccessListListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsAccessListListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsAccessListListRequest) Search(search string) ApiOrganizationsOrganizationsAccessListListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsAccessListListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsAccessListListExecute(r)
}

/*
 * OrganizationsOrganizationsAccessListList  List Users
 *
Make a GET request to this resource to retrieve the list of
users.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of users
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more user records.

## Results

Each user data structure includes the following fields:

* `id`: Database ID for this user. (integer)
* `type`: Data type for this user. (choice)
* `url`: URL for this user. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this user was created. (datetime)
* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string)
* `first_name`:  (string)
* `last_name`:  (string)
* `email`:  (string)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean)
* `is_system_auditor`:  (boolean)

* `ldap_dn`:  (string)
* `last_login`:  (datetime)
* `external_account`: Set if the account is managed by an external service (field)



## Sorting

To specify that users are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=username

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-username

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=username,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsAccessListListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsAccessListList(ctx _context.Context, id string) ApiOrganizationsOrganizationsAccessListListRequest {
	return ApiOrganizationsOrganizationsAccessListListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsAccessListListExecute(r ApiOrganizationsOrganizationsAccessListListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsAccessListList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/access_list/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsActivityStreamListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsActivityStreamListRequest) Page(page int32) ApiOrganizationsOrganizationsActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsActivityStreamListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsActivityStreamListRequest) Search(search string) ApiOrganizationsOrganizationsActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsActivityStreamListExecute(r)
}

/*
 * OrganizationsOrganizationsActivityStreamList  List Activity Streams for an Organization
 *
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsActivityStreamListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsActivityStreamList(ctx _context.Context, id string) ApiOrganizationsOrganizationsActivityStreamListRequest {
	return ApiOrganizationsOrganizationsActivityStreamListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsActivityStreamListExecute(r ApiOrganizationsOrganizationsActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsAdminsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsAdminsCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsAdminsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsAdminsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsAdminsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsAdminsCreate  Create an Admin User for an Organization
 *
Make a POST request to this resource with the following admin user
fields to create a new admin user associated with this
organization.








* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string, required)
* `first_name`:  (string, default=`""`)
* `last_name`:  (string, default=`""`)
* `email`:  (string, default=`""`)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean, default=`False`)
* `is_system_auditor`:  (boolean, default=`False`)
* `password`: Write-only field used to change the password. (string, default=`""`)











# Add Admin Users for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing admin user with this organization.

# Remove Admin Users from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the admin user from this organization
 without deleting the admin user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsAdminsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsAdminsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsAdminsCreateRequest {
	return ApiOrganizationsOrganizationsAdminsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsAdminsCreateExecute(r ApiOrganizationsOrganizationsAdminsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsAdminsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/admins/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsAdminsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsAdminsListRequest) Page(page int32) ApiOrganizationsOrganizationsAdminsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsAdminsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsAdminsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsAdminsListRequest) Search(search string) ApiOrganizationsOrganizationsAdminsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsAdminsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsAdminsListExecute(r)
}

/*
 * OrganizationsOrganizationsAdminsList  List Admin Users for an Organization
 *
Make a GET request to this resource to retrieve a list of
admin users associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of admin users
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more admin user records.

## Results

Each admin user data structure includes the following fields:

* `id`: Database ID for this user. (integer)
* `type`: Data type for this user. (choice)
* `url`: URL for this user. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this user was created. (datetime)
* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string)
* `first_name`:  (string)
* `last_name`:  (string)
* `email`:  (string)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean)
* `is_system_auditor`:  (boolean)

* `ldap_dn`:  (string)
* `last_login`:  (datetime)
* `external_account`: Set if the account is managed by an external service (field)



## Sorting

To specify that admin users are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=username

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-username

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=username,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsAdminsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsAdminsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsAdminsListRequest {
	return ApiOrganizationsOrganizationsAdminsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsAdminsListExecute(r ApiOrganizationsOrganizationsAdminsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsAdminsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/admins/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsApplicationsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject44
}

func (r ApiOrganizationsOrganizationsApplicationsCreateRequest) Data(data InlineObject44) ApiOrganizationsOrganizationsApplicationsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsApplicationsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsApplicationsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsApplicationsCreate  Create an Application for an Organization
 *
Make a POST request to this resource with the following application
fields to create a new application associated with this
organization.









* `name`: Name of this application. (string, required)
* `description`: Optional description of this application. (string, default=`""`)


* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice, required)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string, default=`""`)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice, required)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean, default=`False`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsApplicationsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsApplicationsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsApplicationsCreateRequest {
	return ApiOrganizationsOrganizationsApplicationsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsApplicationsCreateExecute(r ApiOrganizationsOrganizationsApplicationsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsApplicationsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/applications/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsApplicationsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsApplicationsListRequest) Page(page int32) ApiOrganizationsOrganizationsApplicationsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsApplicationsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsApplicationsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsApplicationsListRequest) Search(search string) ApiOrganizationsOrganizationsApplicationsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsApplicationsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsApplicationsListExecute(r)
}

/*
 * OrganizationsOrganizationsApplicationsList  List Applications for an Organization
 *
Make a GET request to this resource to retrieve a list of
applications associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of applications
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more application records.

## Results

Each application data structure includes the following fields:

* `id`: Database ID for this application. (integer)
* `type`: Data type for this application. (choice)
* `url`: URL for this application. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this application was created. (datetime)
* `modified`: Timestamp when this application was last modified. (datetime)
* `name`: Name of this application. (string)
* `description`: Optional description of this application. (string)
* `client_id`:  (string)
* `client_secret`: Used for more stringent verification of access to an application when creating a token. (string)
* `client_type`: Set to Public or Confidential depending on how secure the client device is. (choice)
    - `confidential`: Confidential
    - `public`: Public
* `redirect_uris`: Allowed URIs list, space separated (string)
* `authorization_grant_type`: The Grant type the user must use for acquire tokens for this application. (choice)
    - `authorization-code`: Authorization code
    - `password`: Resource owner password-based
* `skip_authorization`: Set True to skip authorization step for completely trusted applications. (boolean)
* `organization`: Organization containing this application. (id)



## Sorting

To specify that applications are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsApplicationsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsApplicationsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsApplicationsListRequest {
	return ApiOrganizationsOrganizationsApplicationsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsApplicationsListExecute(r ApiOrganizationsOrganizationsApplicationsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsApplicationsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/applications/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsCreate  Create an Organization
 *
Make a POST request to this resource with the following organization
fields to create a new organization:









* `name`: Name of this organization. (string, required)
* `description`: Optional description of this organization. (string, default=`""`)
* `max_hosts`: Maximum number of hosts allowed to be managed by this organization. (integer, default=`0`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrganizationsOrganizationsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsCreate(ctx _context.Context) ApiOrganizationsOrganizationsCreateRequest {
	return ApiOrganizationsOrganizationsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsCreateExecute(r ApiOrganizationsOrganizationsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsCredentialsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject45
}

func (r ApiOrganizationsOrganizationsCredentialsCreateRequest) Data(data InlineObject45) ApiOrganizationsOrganizationsCredentialsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsCredentialsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsCredentialsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsCredentialsCreate  Create a Credential for an Organization
 *
Make a POST request to this resource with the following credential
fields to create a new credential associated with this
organization.









* `name`: Name of this credential. (string, required)
* `description`: Optional description of this credential. (string, default=`""`)

* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id, required)

* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json, default=`{}`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsCredentialsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsCredentialsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsCredentialsCreateRequest {
	return ApiOrganizationsOrganizationsCredentialsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsCredentialsCreateExecute(r ApiOrganizationsOrganizationsCredentialsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsCredentialsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsCredentialsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsCredentialsListRequest) Page(page int32) ApiOrganizationsOrganizationsCredentialsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsCredentialsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsCredentialsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsCredentialsListRequest) Search(search string) ApiOrganizationsOrganizationsCredentialsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsCredentialsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsCredentialsListExecute(r)
}

/*
 * OrganizationsOrganizationsCredentialsList  List Credentials for an Organization
 *
Make a GET request to this resource to retrieve a list of
credentials associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of credentials
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more credential records.

## Results

Each credential data structure includes the following fields:

* `id`: Database ID for this credential. (integer)
* `type`: Data type for this credential. (choice)
* `url`: URL for this credential. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this credential was created. (datetime)
* `modified`: Timestamp when this credential was last modified. (datetime)
* `name`: Name of this credential. (string)
* `description`: Optional description of this credential. (string)
* `organization`: Inherit permissions from organization roles. If provided on creation, do not give either user or team. (id)
* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id)
* `managed_by_tower`:  (boolean)
* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json)
* `kind`:  (field)
* `cloud`:  (field)
* `kubernetes`:  (field)



## Sorting

To specify that credentials are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsCredentialsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsCredentialsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsCredentialsListRequest {
	return ApiOrganizationsOrganizationsCredentialsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsCredentialsListExecute(r ApiOrganizationsOrganizationsCredentialsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsCredentialsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsDeleteRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	search     *string
}

func (r ApiOrganizationsOrganizationsDeleteRequest) Search(search string) ApiOrganizationsOrganizationsDeleteRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsDeleteExecute(r)
}

/*
 * OrganizationsOrganizationsDelete  Delete an Organization
 *
Make a DELETE request to this resource to delete this organization.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsDeleteRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsDelete(ctx _context.Context, id string) ApiOrganizationsOrganizationsDeleteRequest {
	return ApiOrganizationsOrganizationsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsDeleteExecute(r ApiOrganizationsOrganizationsDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsGalaxyCredentialsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsGalaxyCredentialsCreate  Create a Credential for an Organization
 *
Make a POST request to this resource with the following credential
fields to create a new credential associated with this
organization.









* `name`: Name of this credential. (string, required)
* `description`: Optional description of this credential. (string, default=`""`)
* `organization`:  (id, default=`None`)
* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id, required)

* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json, default=`{}`)











# Add Credentials for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing credential with this organization.

# Remove Credentials from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the credential from this organization
 without deleting the credential.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsGalaxyCredentialsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest {
	return ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsGalaxyCredentialsCreateExecute(r ApiOrganizationsOrganizationsGalaxyCredentialsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsGalaxyCredentialsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/galaxy_credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsGalaxyCredentialsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsGalaxyCredentialsListRequest) Page(page int32) ApiOrganizationsOrganizationsGalaxyCredentialsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsGalaxyCredentialsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsGalaxyCredentialsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsGalaxyCredentialsListRequest) Search(search string) ApiOrganizationsOrganizationsGalaxyCredentialsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsGalaxyCredentialsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsGalaxyCredentialsListExecute(r)
}

/*
 * OrganizationsOrganizationsGalaxyCredentialsList  List Credentials for an Organization
 *
Make a GET request to this resource to retrieve a list of
credentials associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of credentials
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more credential records.

## Results

Each credential data structure includes the following fields:

* `id`: Database ID for this credential. (integer)
* `type`: Data type for this credential. (choice)
* `url`: URL for this credential. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this credential was created. (datetime)
* `modified`: Timestamp when this credential was last modified. (datetime)
* `name`: Name of this credential. (string)
* `description`: Optional description of this credential. (string)
* `organization`:  (id)
* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id)
* `managed_by_tower`:  (boolean)
* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json)
* `kind`:  (field)
* `cloud`:  (field)
* `kubernetes`:  (field)



## Sorting

To specify that credentials are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsGalaxyCredentialsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsGalaxyCredentialsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsGalaxyCredentialsListRequest {
	return ApiOrganizationsOrganizationsGalaxyCredentialsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsGalaxyCredentialsListExecute(r ApiOrganizationsOrganizationsGalaxyCredentialsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsGalaxyCredentialsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/galaxy_credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsInstanceGroupsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsInstanceGroupsCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsInstanceGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsInstanceGroupsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsInstanceGroupsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsInstanceGroupsCreate  Create an Instance Group for an Organization
 *
Make a POST request to this resource with the following instance group
fields to create a new instance group associated with this
organization.






* `name`: Name of this instance group. (string, required)













* `credential`:  (id, default=``)
* `policy_instance_percentage`: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer, default=`0`)
* `policy_instance_minimum`: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer, default=`0`)
* `policy_instance_list`: List of exact-match Instances that will be assigned to this group (json, default=``)
* `pod_spec_override`:  (string, default=`""`)









# Add Instance Groups for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing instance group with this organization.

# Remove Instance Groups from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the instance group from this organization
 without deleting the instance group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsInstanceGroupsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsInstanceGroupsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsInstanceGroupsCreateRequest {
	return ApiOrganizationsOrganizationsInstanceGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsInstanceGroupsCreateExecute(r ApiOrganizationsOrganizationsInstanceGroupsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsInstanceGroupsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsInstanceGroupsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsInstanceGroupsListRequest) Page(page int32) ApiOrganizationsOrganizationsInstanceGroupsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsInstanceGroupsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsInstanceGroupsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsInstanceGroupsListRequest) Search(search string) ApiOrganizationsOrganizationsInstanceGroupsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsInstanceGroupsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsInstanceGroupsListExecute(r)
}

/*
 * OrganizationsOrganizationsInstanceGroupsList  List Instance Groups for an Organization
 *
Make a GET request to this resource to retrieve a list of
instance groups associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of instance groups
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more instance group records.

## Results

Each instance group data structure includes the following fields:

* `id`: Database ID for this instance group. (integer)
* `type`: Data type for this instance group. (choice)
* `url`: URL for this instance group. (string)
* `related`: Data structure with URLs of related resources. (object)
* `name`: Name of this instance group. (string)
* `created`: Timestamp when this instance group was created. (datetime)
* `modified`: Timestamp when this instance group was last modified. (datetime)
* `capacity`:  (field)
* `committed_capacity`:  (field)
* `consumed_capacity`:  (field)
* `percent_capacity_remaining`:  (field)
* `jobs_running`: Count of jobs in the running or waiting state that are targeted for this instance group (integer)
* `jobs_total`: Count of all jobs that target this instance group (integer)
* `instances`:  (field)
* `controller`: Instance Group to remotely control this group. (id)
* `is_controller`: Indicates whether instance group controls any other group (boolean)
* `is_isolated`: Indicates whether instances in this group are isolated.Isolated groups have a designated controller group. (boolean)
* `is_containerized`: Indicates whether instances in this group are containerized.Containerized groups have a designated Openshift or Kubernetes cluster. (boolean)
* `credential`:  (id)
* `policy_instance_percentage`: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer)
* `policy_instance_minimum`: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer)
* `policy_instance_list`: List of exact-match Instances that will be assigned to this group (json)
* `pod_spec_override`:  (string)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)



## Sorting

To specify that instance groups are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsInstanceGroupsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsInstanceGroupsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsInstanceGroupsListRequest {
	return ApiOrganizationsOrganizationsInstanceGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsInstanceGroupsListExecute(r ApiOrganizationsOrganizationsInstanceGroupsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsInstanceGroupsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsInventoriesListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsInventoriesListRequest) Page(page int32) ApiOrganizationsOrganizationsInventoriesListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsInventoriesListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsInventoriesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsInventoriesListRequest) Search(search string) ApiOrganizationsOrganizationsInventoriesListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsInventoriesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsInventoriesListExecute(r)
}

/*
 * OrganizationsOrganizationsInventoriesList  List Inventories for an Organization
 *
Make a GET request to this resource to retrieve a list of
inventories associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of inventories
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more inventory records.

## Results

Each inventory data structure includes the following fields:

* `id`: Database ID for this inventory. (integer)
* `type`: Data type for this inventory. (choice)
* `url`: URL for this inventory. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this inventory was created. (datetime)
* `modified`: Timestamp when this inventory was last modified. (datetime)
* `name`: Name of this inventory. (string)
* `description`: Optional description of this inventory. (string)
* `organization`: Organization containing this inventory. (id)
* `kind`: Kind of inventory being represented. (choice)
    - `""`: Hosts have a direct link to this inventory.
    - `smart`: Hosts for inventory generated using the host_filter property.
* `host_filter`: Filter that will be applied to the hosts of this inventory. (string)
* `variables`: Inventory variables in JSON or YAML format. (json)
* `has_active_failures`: This field is deprecated and will be removed in a future release. Flag indicating whether any hosts in this inventory have failed. (boolean)
* `total_hosts`: This field is deprecated and will be removed in a future release. Total number of hosts in this inventory. (integer)
* `hosts_with_active_failures`: This field is deprecated and will be removed in a future release. Number of hosts in this inventory with active failures. (integer)
* `total_groups`: This field is deprecated and will be removed in a future release. Total number of groups in this inventory. (integer)
* `has_inventory_sources`: This field is deprecated and will be removed in a future release. Flag indicating whether this inventory has any external inventory sources. (boolean)
* `total_inventory_sources`: Total number of external inventory sources configured within this inventory. (integer)
* `inventory_sources_with_failures`: Number of external inventory sources in this inventory with failures. (integer)
* `insights_credential`: Credentials to be used by hosts belonging to this inventory when accessing Red Hat Insights API. (id)
* `pending_deletion`: Flag indicating the inventory is being deleted. (boolean)



## Sorting

To specify that inventories are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsInventoriesListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsInventoriesList(ctx _context.Context, id string) ApiOrganizationsOrganizationsInventoriesListRequest {
	return ApiOrganizationsOrganizationsInventoriesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsInventoriesListExecute(r ApiOrganizationsOrganizationsInventoriesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsInventoriesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/inventories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsJobTemplatesCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject46
}

func (r ApiOrganizationsOrganizationsJobTemplatesCreateRequest) Data(data InlineObject46) ApiOrganizationsOrganizationsJobTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsJobTemplatesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsJobTemplatesCreateExecute(r)
}

/*
 * OrganizationsOrganizationsJobTemplatesCreate  Create a Job Template for an Organization
 *
Make a POST request to this resource with the following job template
fields to create a new job template associated with this
organization.









* `name`: Name of this job template. (string, required)
* `description`: Optional description of this job template. (string, default=`""`)
* `job_type`:  (choice)
    - `run`: Run (default)
    - `check`: Check
* `inventory`:  (id, default=``)
* `project`:  (id, default=``)
* `playbook`:  (string, default=`""`)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default=`""`)
* `forks`:  (integer, default=`0`)
* `limit`:  (string, default=`""`)
* `verbosity`:  (choice)
    - `0`: 0 (Normal) (default)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json, default=``)
* `job_tags`:  (string, default=`""`)
* `force_handlers`:  (boolean, default=`False`)
* `skip_tags`:  (string, default=`""`)
* `start_at_task`:  (string, default=`""`)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer, default=`0`)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default=`False`)





* `host_config_key`:  (string, default=`""`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_diff_mode_on_launch`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `ask_tags_on_launch`:  (boolean, default=`False`)
* `ask_skip_tags_on_launch`:  (boolean, default=`False`)
* `ask_job_type_on_launch`:  (boolean, default=`False`)
* `ask_verbosity_on_launch`:  (boolean, default=`False`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_credential_on_launch`:  (boolean, default=`False`)
* `survey_enabled`:  (boolean, default=`False`)
* `become_enabled`:  (boolean, default=`False`)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default=`1`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsJobTemplatesCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsJobTemplatesCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsJobTemplatesCreateRequest {
	return ApiOrganizationsOrganizationsJobTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsJobTemplatesCreateExecute(r ApiOrganizationsOrganizationsJobTemplatesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsJobTemplatesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/job_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsJobTemplatesListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsJobTemplatesListRequest) Page(page int32) ApiOrganizationsOrganizationsJobTemplatesListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsJobTemplatesListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsJobTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsJobTemplatesListRequest) Search(search string) ApiOrganizationsOrganizationsJobTemplatesListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsJobTemplatesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsJobTemplatesListExecute(r)
}

/*
 * OrganizationsOrganizationsJobTemplatesList  List Job Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
job templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of job templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more job template records.

## Results

Each job template data structure includes the following fields:

* `id`: Database ID for this job template. (integer)
* `type`: Data type for this job template. (choice)
* `url`: URL for this job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this job template was created. (datetime)
* `modified`: Timestamp when this job template was last modified. (datetime)
* `name`: Name of this job template. (string)
* `description`: Optional description of this job template. (string)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
* `inventory`:  (id)
* `project`:  (id)
* `playbook`:  (string)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string)
* `forks`:  (integer)
* `limit`:  (string)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json)
* `job_tags`:  (string)
* `force_handlers`:  (boolean)
* `skip_tags`:  (string)
* `start_at_task`:  (string)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean)
* `organization`: The organization used to determine access to this template. (id)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
* `host_config_key`:  (string)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_diff_mode_on_launch`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `ask_tags_on_launch`:  (boolean)
* `ask_skip_tags_on_launch`:  (boolean)
* `ask_job_type_on_launch`:  (boolean)
* `ask_verbosity_on_launch`:  (boolean)
* `ask_inventory_on_launch`:  (boolean)
* `ask_credential_on_launch`:  (boolean)
* `survey_enabled`:  (boolean)
* `become_enabled`:  (boolean)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean)
* `allow_simultaneous`:  (boolean)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)



## Sorting

To specify that job templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsJobTemplatesListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsJobTemplatesList(ctx _context.Context, id string) ApiOrganizationsOrganizationsJobTemplatesListRequest {
	return ApiOrganizationsOrganizationsJobTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsJobTemplatesListExecute(r ApiOrganizationsOrganizationsJobTemplatesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsJobTemplatesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/job_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsListRequest) Page(page int32) ApiOrganizationsOrganizationsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsListRequest) Search(search string) ApiOrganizationsOrganizationsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsListExecute(r)
}

/*
 * OrganizationsOrganizationsList  List Organizations
 *
Make a GET request to this resource to retrieve the list of
organizations.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of organizations
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more organization records.

## Results

Each organization data structure includes the following fields:

* `id`: Database ID for this organization. (integer)
* `type`: Data type for this organization. (choice)
* `url`: URL for this organization. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this organization was created. (datetime)
* `modified`: Timestamp when this organization was last modified. (datetime)
* `name`: Name of this organization. (string)
* `description`: Optional description of this organization. (string)
* `max_hosts`: Maximum number of hosts allowed to be managed by this organization. (integer)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)



## Sorting

To specify that organizations are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrganizationsOrganizationsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsList(ctx _context.Context) ApiOrganizationsOrganizationsListRequest {
	return ApiOrganizationsOrganizationsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsListExecute(r ApiOrganizationsOrganizationsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesApprovalsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesApprovalsCreate  Create a Notification Template for an Organization
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
organization.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this organization.

# Remove Notification Templates from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this organization
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesApprovalsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesApprovalsCreateExecute(r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesApprovalsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest) Page(page int32) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest) Search(search string) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesApprovalsListExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesApprovalsList  List Notification Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesApprovalsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesApprovalsListExecute(r ApiOrganizationsOrganizationsNotificationTemplatesApprovalsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesApprovalsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject47
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest) Data(data InlineObject47) ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesCreateExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesCreate  Create a Notification Template for an Organization
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
organization.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)

* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Remove Organization Notification Templates:

Make a POST request to this resource with `id` and `disassociate` fields to
delete the associated notification template.

    {
        "id": 123,
        "disassociate": true
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesCreateExecute(r ApiOrganizationsOrganizationsNotificationTemplatesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject48
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest) Data(data InlineObject48) ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesErrorCreateExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesErrorCreate  Create a Notification Template for an Organization
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
organization.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this organization.

# Remove Notification Templates from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this organization
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesErrorCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesErrorCreateExecute(r ApiOrganizationsOrganizationsNotificationTemplatesErrorCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesErrorCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest) Page(page int32) ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest) Search(search string) ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesErrorListExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesErrorList  List Notification Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesErrorList(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesErrorListExecute(r ApiOrganizationsOrganizationsNotificationTemplatesErrorListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesErrorList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesListRequest) Page(page int32) ApiOrganizationsOrganizationsNotificationTemplatesListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsNotificationTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesListRequest) Search(search string) ApiOrganizationsOrganizationsNotificationTemplatesListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesListExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesList  List Notification Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesList(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesListRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesListExecute(r ApiOrganizationsOrganizationsNotificationTemplatesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesStartedCreateExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesStartedCreate  Create a Notification Template for an Organization
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
organization.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this organization.

# Remove Notification Templates from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this organization
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesStartedCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesStartedCreateExecute(r ApiOrganizationsOrganizationsNotificationTemplatesStartedCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesStartedCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest) Page(page int32) ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest) Search(search string) ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesStartedListExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesStartedList  List Notification Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesStartedList(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesStartedListExecute(r ApiOrganizationsOrganizationsNotificationTemplatesStartedListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesStartedList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject49
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest) Data(data InlineObject49) ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesSuccessCreateExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesSuccessCreate  Create a Notification Template for an Organization
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
organization.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this organization.

# Remove Notification Templates from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this organization
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesSuccessCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesSuccessCreateExecute(r ApiOrganizationsOrganizationsNotificationTemplatesSuccessCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesSuccessCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest) Page(page int32) ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest) Search(search string) ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsNotificationTemplatesSuccessListExecute(r)
}

/*
 * OrganizationsOrganizationsNotificationTemplatesSuccessList  List Notification Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesSuccessList(ctx _context.Context, id string) ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest {
	return ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsNotificationTemplatesSuccessListExecute(r ApiOrganizationsOrganizationsNotificationTemplatesSuccessListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsNotificationTemplatesSuccessList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsObjectRolesListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsObjectRolesListRequest) Page(page int32) ApiOrganizationsOrganizationsObjectRolesListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsObjectRolesListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsObjectRolesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsObjectRolesListRequest) Search(search string) ApiOrganizationsOrganizationsObjectRolesListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsObjectRolesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsObjectRolesListExecute(r)
}

/*
 * OrganizationsOrganizationsObjectRolesList  List Roles for an Organization
 *
Make a GET request to this resource to retrieve a list of
roles associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of roles
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more role records.

## Results

Each role data structure includes the following fields:

* `id`: Database ID for this role. (integer)
* `type`: Data type for this role. (choice)
* `url`: URL for this role. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `name`: Name of this role. (field)
* `description`: Optional description of this role. (field)



## Sorting

To specify that roles are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsObjectRolesListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsObjectRolesList(ctx _context.Context, id string) ApiOrganizationsOrganizationsObjectRolesListRequest {
	return ApiOrganizationsOrganizationsObjectRolesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsObjectRolesListExecute(r ApiOrganizationsOrganizationsObjectRolesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsObjectRolesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/object_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsPartialUpdateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	search     *string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsPartialUpdateRequest) Search(search string) ApiOrganizationsOrganizationsPartialUpdateRequest {
	r.search = &search
	return r
}
func (r ApiOrganizationsOrganizationsPartialUpdateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsPartialUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsPartialUpdateExecute(r)
}

/*
 * OrganizationsOrganizationsPartialUpdate  Update an Organization
 *
Make a PUT or PATCH request to this resource to update this
organization.  The following fields may be modified:









* `name`: Name of this organization. (string, required)
* `description`: Optional description of this organization. (string, default=`""`)
* `max_hosts`: Maximum number of hosts allowed to be managed by this organization. (integer, default=`0`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)








For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsPartialUpdateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsPartialUpdate(ctx _context.Context, id string) ApiOrganizationsOrganizationsPartialUpdateRequest {
	return ApiOrganizationsOrganizationsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsPartialUpdateExecute(r ApiOrganizationsOrganizationsPartialUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsPartialUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsProjectsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject50
}

func (r ApiOrganizationsOrganizationsProjectsCreateRequest) Data(data InlineObject50) ApiOrganizationsOrganizationsProjectsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsProjectsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsProjectsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsProjectsCreate  Create a Project for an Organization
 *
Make a POST request to this resource with the following project
fields to create a new project associated with this
organization.









* `name`: Name of this project. (string, required)
* `description`: Optional description of this project. (string, default=`""`)
* `local_path`: Local path (relative to PROJECTS_ROOT) containing playbooks and related files for this project. (string, default=`""`)
* `scm_type`: Specifies the source control system used to store the project. (choice)
    - `""`: Manual (default)
    - `git`: Git
    - `hg`: Mercurial
    - `svn`: Subversion
    - `insights`: Red Hat Insights
    - `archive`: Remote Archive
* `scm_url`: The location where the project is stored. (string, default=`""`)
* `scm_branch`: Specific branch, tag or commit to checkout. (string, default=`""`)
* `scm_refspec`: For git projects, an additional refspec to fetch. (string, default=`""`)
* `scm_clean`: Discard any local changes before syncing the project. (boolean, default=`False`)
* `scm_delete_on_update`: Delete the project before syncing. (boolean, default=`False`)
* `credential`:  (id, default=``)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer, default=`0`)






* `scm_update_on_launch`: Update the project when a job is launched that uses the project. (boolean, default=`False`)
* `scm_update_cache_timeout`: The number of seconds after the last project update ran that a new project update will be launched as a job dependency. (integer, default=`0`)
* `allow_override`: Allow changing the SCM branch or revision in a job template that uses this project. (boolean, default=`False`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsProjectsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsProjectsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsProjectsCreateRequest {
	return ApiOrganizationsOrganizationsProjectsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsProjectsCreateExecute(r ApiOrganizationsOrganizationsProjectsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsProjectsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/projects/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsProjectsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsProjectsListRequest) Page(page int32) ApiOrganizationsOrganizationsProjectsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsProjectsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsProjectsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsProjectsListRequest) Search(search string) ApiOrganizationsOrganizationsProjectsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsProjectsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsProjectsListExecute(r)
}

/*
 * OrganizationsOrganizationsProjectsList  List Projects for an Organization
 *
Make a GET request to this resource to retrieve a list of
projects associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of projects
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more project records.

## Results

Each project data structure includes the following fields:

* `id`: Database ID for this project. (integer)
* `type`: Data type for this project. (choice)
* `url`: URL for this project. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this project was created. (datetime)
* `modified`: Timestamp when this project was last modified. (datetime)
* `name`: Name of this project. (string)
* `description`: Optional description of this project. (string)
* `local_path`: Local path (relative to PROJECTS_ROOT) containing playbooks and related files for this project. (string)
* `scm_type`: Specifies the source control system used to store the project. (choice)
    - `""`: Manual
    - `git`: Git
    - `hg`: Mercurial
    - `svn`: Subversion
    - `insights`: Red Hat Insights
    - `archive`: Remote Archive
* `scm_url`: The location where the project is stored. (string)
* `scm_branch`: Specific branch, tag or commit to checkout. (string)
* `scm_refspec`: For git projects, an additional refspec to fetch. (string)
* `scm_clean`: Discard any local changes before syncing the project. (boolean)
* `scm_delete_on_update`: Delete the project before syncing. (boolean)
* `credential`:  (id)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer)
* `scm_revision`: The last revision fetched by a project update (string)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
    - `ok`: OK
    - `missing`: Missing
* `organization`: The organization used to determine access to this template. (id)
* `scm_update_on_launch`: Update the project when a job is launched that uses the project. (boolean)
* `scm_update_cache_timeout`: The number of seconds after the last project update ran that a new project update will be launched as a job dependency. (integer)
* `allow_override`: Allow changing the SCM branch or revision in a job template that uses this project. (boolean)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)
* `last_update_failed`:  (boolean)
* `last_updated`:  (datetime)



## Sorting

To specify that projects are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsProjectsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsProjectsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsProjectsListRequest {
	return ApiOrganizationsOrganizationsProjectsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsProjectsListExecute(r ApiOrganizationsOrganizationsProjectsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsProjectsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/projects/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsReadRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	search     *string
}

func (r ApiOrganizationsOrganizationsReadRequest) Search(search string) ApiOrganizationsOrganizationsReadRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsReadExecute(r)
}

/*
 * OrganizationsOrganizationsRead  Retrieve an Organization
 *
Make GET request to this resource to retrieve a single organization
record containing the following fields:

* `id`: Database ID for this organization. (integer)
* `type`: Data type for this organization. (choice)
* `url`: URL for this organization. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this organization was created. (datetime)
* `modified`: Timestamp when this organization was last modified. (datetime)
* `name`: Name of this organization. (string)
* `description`: Optional description of this organization. (string)
* `max_hosts`: Maximum number of hosts allowed to be managed by this organization. (integer)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsReadRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsRead(ctx _context.Context, id string) ApiOrganizationsOrganizationsReadRequest {
	return ApiOrganizationsOrganizationsReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsReadExecute(r ApiOrganizationsOrganizationsReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsTeamsCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject51
}

func (r ApiOrganizationsOrganizationsTeamsCreateRequest) Data(data InlineObject51) ApiOrganizationsOrganizationsTeamsCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsTeamsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsTeamsCreateExecute(r)
}

/*
 * OrganizationsOrganizationsTeamsCreate  Create a Team for an Organization
 *
Make a POST request to this resource with the following team
fields to create a new team associated with this
organization.









* `name`: Name of this team. (string, required)
* `description`: Optional description of this team. (string, default=`""`)









# Remove Organization Teams:

Make a POST request to this resource with `id` and `disassociate` fields to
delete the associated team.

    {
        "id": 123,
        "disassociate": true
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsTeamsCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsTeamsCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsTeamsCreateRequest {
	return ApiOrganizationsOrganizationsTeamsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsTeamsCreateExecute(r ApiOrganizationsOrganizationsTeamsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsTeamsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/teams/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsTeamsListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsTeamsListRequest) Page(page int32) ApiOrganizationsOrganizationsTeamsListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsTeamsListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsTeamsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsTeamsListRequest) Search(search string) ApiOrganizationsOrganizationsTeamsListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsTeamsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsTeamsListExecute(r)
}

/*
 * OrganizationsOrganizationsTeamsList  List Teams for an Organization
 *
Make a GET request to this resource to retrieve a list of
teams associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of teams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more team records.

## Results

Each team data structure includes the following fields:

* `id`: Database ID for this team. (integer)
* `type`: Data type for this team. (choice)
* `url`: URL for this team. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this team was created. (datetime)
* `modified`: Timestamp when this team was last modified. (datetime)
* `name`: Name of this team. (string)
* `description`: Optional description of this team. (string)
* `organization`:  (id)



## Sorting

To specify that teams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsTeamsListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsTeamsList(ctx _context.Context, id string) ApiOrganizationsOrganizationsTeamsListRequest {
	return ApiOrganizationsOrganizationsTeamsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsTeamsListExecute(r ApiOrganizationsOrganizationsTeamsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsTeamsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/teams/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsUpdateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	search     *string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsUpdateRequest) Search(search string) ApiOrganizationsOrganizationsUpdateRequest {
	r.search = &search
	return r
}
func (r ApiOrganizationsOrganizationsUpdateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsUpdateExecute(r)
}

/*
 * OrganizationsOrganizationsUpdate  Update an Organization
 *
Make a PUT or PATCH request to this resource to update this
organization.  The following fields may be modified:









* `name`: Name of this organization. (string, required)
* `description`: Optional description of this organization. (string, default=`""`)
* `max_hosts`: Maximum number of hosts allowed to be managed by this organization. (integer, default=`0`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)






For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsUpdateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsUpdate(ctx _context.Context, id string) ApiOrganizationsOrganizationsUpdateRequest {
	return ApiOrganizationsOrganizationsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsUpdateExecute(r ApiOrganizationsOrganizationsUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsUsersCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiOrganizationsOrganizationsUsersCreateRequest) Data(data map[string]interface{}) ApiOrganizationsOrganizationsUsersCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsUsersCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsUsersCreateExecute(r)
}

/*
 * OrganizationsOrganizationsUsersCreate  Create a User for an Organization
 *
Make a POST request to this resource with the following user
fields to create a new user associated with this
organization.








* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string, required)
* `first_name`:  (string, default=`""`)
* `last_name`:  (string, default=`""`)
* `email`:  (string, default=`""`)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean, default=`False`)
* `is_system_auditor`:  (boolean, default=`False`)
* `password`: Write-only field used to change the password. (string, default=`""`)











# Add Users for an Organization:

Make a POST request to this resource with only an `id` field to associate an
existing user with this organization.

# Remove Users from this Organization:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the user from this organization
 without deleting the user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsUsersCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsUsersCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsUsersCreateRequest {
	return ApiOrganizationsOrganizationsUsersCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsUsersCreateExecute(r ApiOrganizationsOrganizationsUsersCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsUsersCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/users/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsUsersListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsUsersListRequest) Page(page int32) ApiOrganizationsOrganizationsUsersListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsUsersListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsUsersListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsUsersListRequest) Search(search string) ApiOrganizationsOrganizationsUsersListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsUsersListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsUsersListExecute(r)
}

/*
 * OrganizationsOrganizationsUsersList  List Users for an Organization
 *
Make a GET request to this resource to retrieve a list of
users associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of users
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more user records.

## Results

Each user data structure includes the following fields:

* `id`: Database ID for this user. (integer)
* `type`: Data type for this user. (choice)
* `url`: URL for this user. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this user was created. (datetime)
* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string)
* `first_name`:  (string)
* `last_name`:  (string)
* `email`:  (string)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean)
* `is_system_auditor`:  (boolean)

* `ldap_dn`:  (string)
* `last_login`:  (datetime)
* `external_account`: Set if the account is managed by an external service (field)



## Sorting

To specify that users are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=username

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-username

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=username,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsUsersListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsUsersList(ctx _context.Context, id string) ApiOrganizationsOrganizationsUsersListRequest {
	return ApiOrganizationsOrganizationsUsersListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsUsersListExecute(r ApiOrganizationsOrganizationsUsersListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsUsersList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/users/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	data       *InlineObject52
}

func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest) Data(data InlineObject52) ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsWorkflowJobTemplatesCreateExecute(r)
}

/*
 * OrganizationsOrganizationsWorkflowJobTemplatesCreate  Create a Workflow Job Template for an Organization
 *
Make a POST request to this resource with the following workflow job template
fields to create a new workflow job template associated with this
organization.









* `name`: Name of this workflow job template. (string, required)
* `description`: Optional description of this workflow job template. (string, default=`""`)




* `extra_vars`:  (json, default=``)

* `survey_enabled`:  (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `limit`:  (string, default=`""`)
* `scm_branch`:  (string, default=`""`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsWorkflowJobTemplatesCreate(ctx _context.Context, id string) ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest {
	return ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsWorkflowJobTemplatesCreateExecute(r ApiOrganizationsOrganizationsWorkflowJobTemplatesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsWorkflowJobTemplatesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/workflow_job_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest struct {
	ctx        _context.Context
	ApiService *OrganizationsApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest) Page(page int32) ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest {
	r.page = &page
	return r
}
func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest) PageSize(pageSize int32) ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest) Search(search string) ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest {
	r.search = &search
	return r
}

func (r ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrganizationsOrganizationsWorkflowJobTemplatesListExecute(r)
}

/*
 * OrganizationsOrganizationsWorkflowJobTemplatesList  List Workflow Job Templates for an Organization
 *
Make a GET request to this resource to retrieve a list of
workflow job templates associated with the selected
organization.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow job templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job template records.

## Results

Each workflow job template data structure includes the following fields:

* `id`: Database ID for this workflow job template. (integer)
* `type`: Data type for this workflow job template. (choice)
* `url`: URL for this workflow job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job template was created. (datetime)
* `modified`: Timestamp when this workflow job template was last modified. (datetime)
* `name`: Name of this workflow job template. (string)
* `description`: Optional description of this workflow job template. (string)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
    - `ok`: OK
    - `missing`: Missing
    - `none`: No External Source
    - `updating`: Updating
* `extra_vars`:  (json)
* `organization`: The organization used to determine access to this template. (id)
* `survey_enabled`:  (boolean)
* `allow_simultaneous`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `ask_inventory_on_launch`:  (boolean)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)



## Sorting

To specify that workflow job templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest
*/
func (a *OrganizationsApiService) OrganizationsOrganizationsWorkflowJobTemplatesList(ctx _context.Context, id string) ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest {
	return ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *OrganizationsApiService) OrganizationsOrganizationsWorkflowJobTemplatesListExecute(r ApiOrganizationsOrganizationsWorkflowJobTemplatesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsApiService.OrganizationsOrganizationsWorkflowJobTemplatesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{id}/workflow_job_templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
