/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// JobTemplatesApiService JobTemplatesApi service
type JobTemplatesApiService service

// JobTemplatesJobTemplatesAccessListListOpts Optional parameters for the method 'JobTemplatesJobTemplatesAccessListList'
type JobTemplatesJobTemplatesAccessListListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesAccessListList  List Users
 Make a GET request to this resource to retrieve the list of users.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of users found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more user records.    ## Results  Each user data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this user. (integer) * &#x60;type&#x60;: Data type for this user. (choice) * &#x60;url&#x60;: URL for this user. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this user was created. (datetime) * &#x60;username&#x60;: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string) * &#x60;first_name&#x60;:  (string) * &#x60;last_name&#x60;:  (string) * &#x60;email&#x60;:  (string) * &#x60;is_superuser&#x60;: Designates that this user has all permissions without explicitly assigning them. (boolean) * &#x60;is_system_auditor&#x60;:  (boolean)  * &#x60;ldap_dn&#x60;:  (string) * &#x60;last_login&#x60;:  (datetime) * &#x60;external_account&#x60;: Set if the account is managed by an external service (field)    ## Sorting  To specify that users are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;username  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-username  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;username,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesAccessListListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesAccessListList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesAccessListListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/access_list/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesActivityStreamListOpts Optional parameters for the method 'JobTemplatesJobTemplatesActivityStreamList'
type JobTemplatesJobTemplatesActivityStreamListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesActivityStreamList  List Activity Streams for a Job Template
 Make a GET request to this resource to retrieve a list of activity streams associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of activity streams found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more activity stream records.    ## Results  Each activity stream data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this activity stream. (integer) * &#x60;type&#x60;: Data type for this activity stream. (choice) * &#x60;url&#x60;: URL for this activity stream. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;timestamp&#x60;:  (datetime) * &#x60;operation&#x60;: The action taken with respect to the given object(s). (choice)     - &#x60;create&#x60;: Entity Created     - &#x60;update&#x60;: Entity Updated     - &#x60;delete&#x60;: Entity Deleted     - &#x60;associate&#x60;: Entity Associated with another Entity     - &#x60;disassociate&#x60;: Entity was Disassociated with another Entity * &#x60;changes&#x60;: A summary of the new and changed values when an object is created, updated, or deleted (json) * &#x60;object1&#x60;: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string) * &#x60;object2&#x60;: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string) * &#x60;object_association&#x60;: When present, shows the field name of the role or relationship that changed. (field) * &#x60;action_node&#x60;: The cluster node the activity took place on. (string) * &#x60;object_type&#x60;: When present, shows the model on which the role or relationship was defined. (field)    ## Sorting  To specify that activity streams are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesActivityStreamListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesActivityStreamList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesActivityStreamListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCallbackCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesCallbackCreate'
type JobTemplatesJobTemplatesCallbackCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesCallbackCreate The job template callback allows for ephemeral hosts to launch a new job.
 Configure a host to POST to this resource, passing the &#x60;host_config_key&#x60; parameter, to start a new job limited to only the requesting host.  In the examples below, replace the &#x60;N&#x60; parameter with the &#x60;id&#x60; of the job template and the &#x60;HOST_CONFIG_KEY&#x60; with the &#x60;host_config_key&#x60; associated with the job template.  For example, using curl:      curl -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;}&#39;  http://server/api/v2/job_templates/N/callback/  Or using wget:      wget -O /dev/null --post-data&#x3D;&#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;}&#39; --header&#x3D;Content-Type:application/json http://server/api/v2/job_templates/N/callback/  You may also pass &#x60;extra_vars&#x60; to the callback:      curl -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;, \&quot;extra_vars\&quot;: {\&quot;key\&quot;: \&quot;value\&quot;}}&#39;  http://server/api/v2/job_templates/N/callback/      The response will return status 202 if the request is valid, 403 for an invalid host config key, or 400 if the host cannot be determined from the address making the request.  _(New in Ansible Tower 2.0.0)_  If the associated inventory has the &#x60;update_on_launch&#x60; flag set and if the &#x60;update_cache_timeout&#x60; has expired, the callback will perform an inventory sync to find a matching host.  A GET request may be used to verify that the correct host will be selected. This request must authenticate as a valid user with permission to edit the job template.  For example:      curl http://user:password@server/api/v2/job_templates/N/callback/  The response will include the host config key as well as the host name(s) that would match the request:      {         \&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;,         \&quot;matching_hosts\&quot;: [\&quot;hostname\&quot;]     }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCallbackCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCallbackCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/callback/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCallbackListOpts Optional parameters for the method 'JobTemplatesJobTemplatesCallbackList'
type JobTemplatesJobTemplatesCallbackListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesCallbackList The job template callback allows for ephemeral hosts to launch a new job.
 Configure a host to POST to this resource, passing the &#x60;host_config_key&#x60; parameter, to start a new job limited to only the requesting host.  In the examples below, replace the &#x60;N&#x60; parameter with the &#x60;id&#x60; of the job template and the &#x60;HOST_CONFIG_KEY&#x60; with the &#x60;host_config_key&#x60; associated with the job template.  For example, using curl:      curl -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;}&#39;  http://server/api/v2/job_templates/N/callback/  Or using wget:      wget -O /dev/null --post-data&#x3D;&#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;}&#39; --header&#x3D;Content-Type:application/json http://server/api/v2/job_templates/N/callback/  You may also pass &#x60;extra_vars&#x60; to the callback:      curl -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;, \&quot;extra_vars\&quot;: {\&quot;key\&quot;: \&quot;value\&quot;}}&#39;  http://server/api/v2/job_templates/N/callback/      The response will return status 202 if the request is valid, 403 for an invalid host config key, or 400 if the host cannot be determined from the address making the request.  _(New in Ansible Tower 2.0.0)_  If the associated inventory has the &#x60;update_on_launch&#x60; flag set and if the &#x60;update_cache_timeout&#x60; has expired, the callback will perform an inventory sync to find a matching host.  A GET request may be used to verify that the correct host will be selected. This request must authenticate as a valid user with permission to edit the job template.  For example:      curl http://user:password@server/api/v2/job_templates/N/callback/  The response will include the host config key as well as the host name(s) that would match the request:      {         \&quot;host_config_key\&quot;: \&quot;HOST_CONFIG_KEY\&quot;,         \&quot;matching_hosts\&quot;: [\&quot;hostname\&quot;]     }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCallbackListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCallbackListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/callback/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCopyCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesCopyCreate'
type JobTemplatesJobTemplatesCopyCreateOpts struct {
    Data optional.Interface
}

/*
JobTemplatesJobTemplatesCopyCreate Method for JobTemplatesJobTemplatesCopyCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCopyCreateOpts - Optional Parameters:
 * @param "Data" (optional.Interface of InlineObject32) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCopyCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(InlineObject32)
		if !localVarOptionalDataok {
			return nil, reportError("data should be InlineObject32")
		}
		localVarPostBody = &localVarOptionalData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCopyListOpts Optional parameters for the method 'JobTemplatesJobTemplatesCopyList'
type JobTemplatesJobTemplatesCopyListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesCopyList Method for JobTemplatesJobTemplatesCopyList
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCopyListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCopyListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesCreate'
type JobTemplatesJobTemplatesCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesCreate  Create a Job Template
 Make a POST request to this resource with the following job template fields to create a new job template:          * &#x60;name&#x60;: Name of this job template. (string, required) * &#x60;description&#x60;: Optional description of this job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run (default)     - &#x60;check&#x60;: Check * &#x60;inventory&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;project&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;playbook&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;forks&#x60;:  (integer, default&#x3D;&#x60;0&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal) (default)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;force_handlers&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;start_at_task&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer, default&#x3D;&#x60;0&#x60;) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default&#x3D;&#x60;False&#x60;)      * &#x60;host_config_key&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_diff_mode_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_skip_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_job_type_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_verbosity_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_credential_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;become_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;custom_virtualenv&#x60;: Local absolute file path containing a custom Python virtualenv to use (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_slice_count&#x60;: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default&#x3D;&#x60;1&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobTemplatesJobTemplatesCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCreate(ctx _context.Context, localVarOptionals *JobTemplatesJobTemplatesCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCredentialsCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesCredentialsCreate'
type JobTemplatesJobTemplatesCredentialsCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesCredentialsCreate  Create a Credential for a Job Template
 Make a POST request to this resource with the following credential fields to create a new credential associated with this job template.          * &#x60;name&#x60;: Name of this credential. (string, required) * &#x60;description&#x60;: Optional description of this credential. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, default&#x3D;&#x60;None&#x60;) * &#x60;credential_type&#x60;: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id, required)  * &#x60;inputs&#x60;: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json, default&#x3D;&#x60;{}&#x60;)            # Add Credentials for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing credential with this job template.  # Remove Credentials from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the credential from this job template  without deleting the credential.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCredentialsCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCredentialsCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesCredentialsListOpts Optional parameters for the method 'JobTemplatesJobTemplatesCredentialsList'
type JobTemplatesJobTemplatesCredentialsListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesCredentialsList  List Credentials for a Job Template
 Make a GET request to this resource to retrieve a list of credentials associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of credentials found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more credential records.    ## Results  Each credential data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this credential. (integer) * &#x60;type&#x60;: Data type for this credential. (choice) * &#x60;url&#x60;: URL for this credential. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this credential was created. (datetime) * &#x60;modified&#x60;: Timestamp when this credential was last modified. (datetime) * &#x60;name&#x60;: Name of this credential. (string) * &#x60;description&#x60;: Optional description of this credential. (string) * &#x60;organization&#x60;:  (id) * &#x60;credential_type&#x60;: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id) * &#x60;managed_by_tower&#x60;:  (boolean) * &#x60;inputs&#x60;: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json) * &#x60;kind&#x60;:  (field) * &#x60;cloud&#x60;:  (field) * &#x60;kubernetes&#x60;:  (field)    ## Sorting  To specify that credentials are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesCredentialsListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesCredentialsListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesDeleteOpts Optional parameters for the method 'JobTemplatesJobTemplatesDelete'
type JobTemplatesJobTemplatesDeleteOpts struct {
    Search optional.String
}

/*
JobTemplatesJobTemplatesDelete  Delete a Job Template
 Make a DELETE request to this resource to delete this job template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesDeleteOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesDelete(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
JobTemplatesJobTemplatesGithubCreate Method for JobTemplatesJobTemplatesGithubCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGithubCreate(ctx _context.Context, id string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/github/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
JobTemplatesJobTemplatesGitlabCreate Method for JobTemplatesJobTemplatesGitlabCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGitlabCreate(ctx _context.Context, id string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/gitlab/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesInstanceGroupsCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesInstanceGroupsCreate'
type JobTemplatesJobTemplatesInstanceGroupsCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesInstanceGroupsCreate  Create an Instance Group for a Job Template
 Make a POST request to this resource with the following instance group fields to create a new instance group associated with this job template.       * &#x60;name&#x60;: Name of this instance group. (string, required)              * &#x60;credential&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;policy_instance_percentage&#x60;: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer, default&#x3D;&#x60;0&#x60;) * &#x60;policy_instance_minimum&#x60;: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer, default&#x3D;&#x60;0&#x60;) * &#x60;policy_instance_list&#x60;: List of exact-match Instances that will be assigned to this group (json, default&#x3D;&#x60;&#x60;) * &#x60;pod_spec_override&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)          # Add Instance Groups for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing instance group with this job template.  # Remove Instance Groups from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the instance group from this job template  without deleting the instance group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesInstanceGroupsCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesInstanceGroupsCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesInstanceGroupsListOpts Optional parameters for the method 'JobTemplatesJobTemplatesInstanceGroupsList'
type JobTemplatesJobTemplatesInstanceGroupsListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesInstanceGroupsList  List Instance Groups for a Job Template
 Make a GET request to this resource to retrieve a list of instance groups associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of instance groups found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more instance group records.    ## Results  Each instance group data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this instance group. (integer) * &#x60;type&#x60;: Data type for this instance group. (choice) * &#x60;url&#x60;: URL for this instance group. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;name&#x60;: Name of this instance group. (string) * &#x60;created&#x60;: Timestamp when this instance group was created. (datetime) * &#x60;modified&#x60;: Timestamp when this instance group was last modified. (datetime) * &#x60;capacity&#x60;:  (field) * &#x60;committed_capacity&#x60;:  (field) * &#x60;consumed_capacity&#x60;:  (field) * &#x60;percent_capacity_remaining&#x60;:  (field) * &#x60;jobs_running&#x60;: Count of jobs in the running or waiting state that are targeted for this instance group (integer) * &#x60;jobs_total&#x60;: Count of all jobs that target this instance group (integer) * &#x60;instances&#x60;:  (field) * &#x60;controller&#x60;: Instance Group to remotely control this group. (id) * &#x60;is_controller&#x60;: Indicates whether instance group controls any other group (boolean) * &#x60;is_isolated&#x60;: Indicates whether instances in this group are isolated.Isolated groups have a designated controller group. (boolean) * &#x60;is_containerized&#x60;: Indicates whether instances in this group are containerized.Containerized groups have a designated Openshift or Kubernetes cluster. (boolean) * &#x60;credential&#x60;:  (id) * &#x60;policy_instance_percentage&#x60;: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer) * &#x60;policy_instance_minimum&#x60;: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer) * &#x60;policy_instance_list&#x60;: List of exact-match Instances that will be assigned to this group (json) * &#x60;pod_spec_override&#x60;:  (string) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)    ## Sorting  To specify that instance groups are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesInstanceGroupsListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesInstanceGroupsListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesJobsListOpts Optional parameters for the method 'JobTemplatesJobTemplatesJobsList'
type JobTemplatesJobTemplatesJobsListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesJobsList  List Jobs for a Job Template
 Make a GET request to this resource to retrieve a list of jobs associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of jobs found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more job records.    ## Results  Each job data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this job. (integer) * &#x60;type&#x60;: Data type for this job. (choice) * &#x60;url&#x60;: URL for this job. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this job was created. (datetime) * &#x60;modified&#x60;: Timestamp when this job was last modified. (datetime) * &#x60;name&#x60;: Name of this job. (string) * &#x60;description&#x60;: Optional description of this job. (string) * &#x60;unified_job_template&#x60;:  (id) * &#x60;launch_type&#x60;:  (choice)     - &#x60;manual&#x60;: Manual     - &#x60;relaunch&#x60;: Relaunch     - &#x60;callback&#x60;: Callback     - &#x60;scheduled&#x60;: Scheduled     - &#x60;dependency&#x60;: Dependency     - &#x60;workflow&#x60;: Workflow     - &#x60;webhook&#x60;: Webhook     - &#x60;sync&#x60;: Sync     - &#x60;scm&#x60;: SCM Update * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled * &#x60;failed&#x60;:  (boolean) * &#x60;started&#x60;: The date and time the job was queued for starting. (datetime) * &#x60;finished&#x60;: The date and time the job finished execution. (datetime) * &#x60;canceled_on&#x60;: The date and time when the cancel request was sent. (datetime) * &#x60;elapsed&#x60;: Elapsed time in seconds that the job ran. (decimal) * &#x60;job_explanation&#x60;: A status field to indicate the state of the job if it wasn&amp;#39;t able to run and capture stdout (string) * &#x60;execution_node&#x60;: The node the job executed on. (string) * &#x60;controller_node&#x60;: The instance that managed the isolated execution environment. (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check     - &#x60;scan&#x60;: Scan * &#x60;inventory&#x60;:  (id) * &#x60;project&#x60;:  (id) * &#x60;playbook&#x60;:  (string) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string) * &#x60;forks&#x60;:  (integer) * &#x60;limit&#x60;:  (string) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json) * &#x60;job_tags&#x60;:  (string) * &#x60;force_handlers&#x60;:  (boolean) * &#x60;skip_tags&#x60;:  (string) * &#x60;start_at_task&#x60;:  (string) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean) * &#x60;organization&#x60;: The organization used to determine access to this unified job. (id) * &#x60;job_template&#x60;:  (id) * &#x60;passwords_needed_to_start&#x60;:  (field) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;artifacts&#x60;:  (json) * &#x60;scm_revision&#x60;: The SCM Revision from the Project used for this job, if available (string) * &#x60;instance_group&#x60;: The Instance group the job was run under (id) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean) * &#x60;job_slice_number&#x60;: If part of a sliced job, the ID of the inventory slice operated on. If not part of sliced job, parameter is not used. (integer) * &#x60;job_slice_count&#x60;: If ran as part of sliced jobs, the total number of slices. If 1, job is not part of a sliced job. (integer) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id) * &#x60;webhook_guid&#x60;: Unique identifier of the event that triggered this webhook (string)    ## Sorting  To specify that jobs are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesJobsListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesJobsList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesJobsListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesLabelsCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesLabelsCreate'
type JobTemplatesJobTemplatesLabelsCreateOpts struct {
    Data optional.Interface
}

/*
JobTemplatesJobTemplatesLabelsCreate  Create a Label for a Job Template
 Make a POST request to this resource with the following label fields to create a new label associated with this job template.          * &#x60;name&#x60;: Name of this label. (string, required) * &#x60;organization&#x60;: Organization this label belongs to. (id, required)         # Add Labels for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing label with this job template.  # Remove Labels from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the label from this job template .     Labels not associated with any other resources are deleted. A label can become disassociated with a resource as a result of 3 events.  1. A label is explicitly disassociated with a related job template 2. A job is deleted with labels 3. A cleanup job deletes a job with labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesLabelsCreateOpts - Optional Parameters:
 * @param "Data" (optional.Interface of InlineObject33) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesLabelsCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(InlineObject33)
		if !localVarOptionalDataok {
			return nil, reportError("data should be InlineObject33")
		}
		localVarPostBody = &localVarOptionalData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesLabelsListOpts Optional parameters for the method 'JobTemplatesJobTemplatesLabelsList'
type JobTemplatesJobTemplatesLabelsListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesLabelsList  List Labels for a Job Template
 Make a GET request to this resource to retrieve a list of labels associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of labels found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more label records.    ## Results  Each label data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this label. (integer) * &#x60;type&#x60;: Data type for this label. (choice) * &#x60;url&#x60;: URL for this label. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this label was created. (datetime) * &#x60;modified&#x60;: Timestamp when this label was last modified. (datetime) * &#x60;name&#x60;: Name of this label. (string) * &#x60;organization&#x60;: Organization this label belongs to. (id)    ## Sorting  To specify that labels are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesLabelsListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesLabelsListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesLaunchCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesLaunchCreate'
type JobTemplatesJobTemplatesLaunchCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesLaunchCreate Launch a Job Template
 Make a GET request to this resource to determine if the job_template can be launched and whether any passwords are required to launch the job_template. The response will include the following fields:  * &#x60;ask_variables_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for variables upon launch (boolean, read-only) * &#x60;ask_tags_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for tags upon launch (boolean, read-only) * &#x60;ask_skip_tags_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for skip_tags upon launch (boolean, read-only) * &#x60;ask_job_type_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for job_type upon launch (boolean, read-only) * &#x60;ask_limit_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for limit upon launch (boolean, read-only) * &#x60;ask_inventory_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for inventory upon launch (boolean, read-only) * &#x60;ask_credential_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for credential upon launch (boolean, read-only) * &#x60;can_start_without_user_input&#x60;: Flag indicating if the job_template can be   launched without user-input (boolean, read-only) * &#x60;passwords_needed_to_start&#x60;: Password names required to launch the   job_template (array, read-only) * &#x60;variables_needed_to_start&#x60;: Required variable names required to launch the   job_template (array, read-only) * &#x60;survey_enabled&#x60;: Flag indicating whether the job_template has an enabled   survey (boolean, read-only) * &#x60;inventory_needed_to_start&#x60;: Flag indicating the presence of an inventory   associated with the job template.  If not then one should be supplied when   launching the job (boolean, read-only)  Make a POST request to this resource to launch the job_template. If any passwords, inventory, or extra variables (extra_vars) are required, they must be passed via POST data, with extra_vars given as a YAML or JSON string and escaped parentheses. If the &#x60;inventory_needed_to_start&#x60; is &#x60;True&#x60; then the &#x60;inventory&#x60; is required.  If successful, the response status code will be 201.  If any required passwords are not provided, a 400 status code will be returned.  If the job cannot be launched, a 405 status code will be returned. If the provided credential or inventory are not allowed to be used by the user, then a 403 status code will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesLaunchCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesLaunchCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesLaunchReadOpts Optional parameters for the method 'JobTemplatesJobTemplatesLaunchRead'
type JobTemplatesJobTemplatesLaunchReadOpts struct {
    Search optional.String
}

/*
JobTemplatesJobTemplatesLaunchRead Launch a Job Template
 Make a GET request to this resource to determine if the job_template can be launched and whether any passwords are required to launch the job_template. The response will include the following fields:  * &#x60;ask_variables_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for variables upon launch (boolean, read-only) * &#x60;ask_tags_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for tags upon launch (boolean, read-only) * &#x60;ask_skip_tags_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for skip_tags upon launch (boolean, read-only) * &#x60;ask_job_type_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for job_type upon launch (boolean, read-only) * &#x60;ask_limit_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for limit upon launch (boolean, read-only) * &#x60;ask_inventory_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for inventory upon launch (boolean, read-only) * &#x60;ask_credential_on_launch&#x60;: Flag indicating whether the job_template is   configured to prompt for credential upon launch (boolean, read-only) * &#x60;can_start_without_user_input&#x60;: Flag indicating if the job_template can be   launched without user-input (boolean, read-only) * &#x60;passwords_needed_to_start&#x60;: Password names required to launch the   job_template (array, read-only) * &#x60;variables_needed_to_start&#x60;: Required variable names required to launch the   job_template (array, read-only) * &#x60;survey_enabled&#x60;: Flag indicating whether the job_template has an enabled   survey (boolean, read-only) * &#x60;inventory_needed_to_start&#x60;: Flag indicating the presence of an inventory   associated with the job template.  If not then one should be supplied when   launching the job (boolean, read-only)  Make a POST request to this resource to launch the job_template. If any passwords, inventory, or extra variables (extra_vars) are required, they must be passed via POST data, with extra_vars given as a YAML or JSON string and escaped parentheses. If the &#x60;inventory_needed_to_start&#x60; is &#x60;True&#x60; then the &#x60;inventory&#x60; is required.  If successful, the response status code will be 201.  If any required passwords are not provided, a 400 status code will be returned.  If the job cannot be launched, a 405 status code will be returned. If the provided credential or inventory are not allowed to be used by the user, then a 403 status code will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesLaunchReadOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchRead(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesLaunchReadOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesListOpts Optional parameters for the method 'JobTemplatesJobTemplatesList'
type JobTemplatesJobTemplatesListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesList  List Job Templates
 Make a GET request to this resource to retrieve the list of job templates.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of job templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more job template records.    ## Results  Each job template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this job template. (integer) * &#x60;type&#x60;: Data type for this job template. (choice) * &#x60;url&#x60;: URL for this job template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this job template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this job template was last modified. (datetime) * &#x60;name&#x60;: Name of this job template. (string) * &#x60;description&#x60;: Optional description of this job template. (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;inventory&#x60;:  (id) * &#x60;project&#x60;:  (id) * &#x60;playbook&#x60;:  (string) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string) * &#x60;forks&#x60;:  (integer) * &#x60;limit&#x60;:  (string) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json) * &#x60;job_tags&#x60;:  (string) * &#x60;force_handlers&#x60;:  (boolean) * &#x60;skip_tags&#x60;:  (string) * &#x60;start_at_task&#x60;:  (string) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean) * &#x60;organization&#x60;: The organization used to determine access to this template. (id) * &#x60;last_job_run&#x60;:  (datetime) * &#x60;last_job_failed&#x60;:  (boolean) * &#x60;next_job_run&#x60;:  (datetime) * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled     - &#x60;never updated&#x60;: Never Updated * &#x60;host_config_key&#x60;:  (string) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean) * &#x60;ask_diff_mode_on_launch&#x60;:  (boolean) * &#x60;ask_variables_on_launch&#x60;:  (boolean) * &#x60;ask_limit_on_launch&#x60;:  (boolean) * &#x60;ask_tags_on_launch&#x60;:  (boolean) * &#x60;ask_skip_tags_on_launch&#x60;:  (boolean) * &#x60;ask_job_type_on_launch&#x60;:  (boolean) * &#x60;ask_verbosity_on_launch&#x60;:  (boolean) * &#x60;ask_inventory_on_launch&#x60;:  (boolean) * &#x60;ask_credential_on_launch&#x60;:  (boolean) * &#x60;survey_enabled&#x60;:  (boolean) * &#x60;become_enabled&#x60;:  (boolean) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;custom_virtualenv&#x60;: Local absolute file path containing a custom Python virtualenv to use (string) * &#x60;job_slice_count&#x60;: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id)    ## Sorting  To specify that job templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobTemplatesJobTemplatesListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesList(ctx _context.Context, localVarOptionals *JobTemplatesJobTemplatesListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesErrorCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesErrorCreate'
type JobTemplatesJobTemplatesNotificationTemplatesErrorCreateOpts struct {
    Data optional.Interface
}

/*
JobTemplatesJobTemplatesNotificationTemplatesErrorCreate  Create a Notification Template for a Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this job template.  # Remove Notification Templates from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this job template  without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesErrorCreateOpts - Optional Parameters:
 * @param "Data" (optional.Interface of InlineObject34) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesErrorCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(InlineObject34)
		if !localVarOptionalDataok {
			return nil, reportError("data should be InlineObject34")
		}
		localVarPostBody = &localVarOptionalData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesErrorListOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesErrorList'
type JobTemplatesJobTemplatesNotificationTemplatesErrorListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesNotificationTemplatesErrorList  List Notification Templates for a Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesErrorListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesErrorListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesStartedCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesStartedCreate'
type JobTemplatesJobTemplatesNotificationTemplatesStartedCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesNotificationTemplatesStartedCreate  Create a Notification Template for a Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this job template.  # Remove Notification Templates from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this job template  without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesStartedCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesStartedCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesStartedListOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesStartedList'
type JobTemplatesJobTemplatesNotificationTemplatesStartedListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesNotificationTemplatesStartedList  List Notification Templates for a Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesStartedListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesStartedListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate'
type JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateOpts struct {
    Data optional.Interface
}

/*
JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate  Create a Notification Template for a Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this job template.  # Remove Notification Templates from this Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this job template  without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateOpts - Optional Parameters:
 * @param "Data" (optional.Interface of InlineObject35) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(InlineObject35)
		if !localVarOptionalDataok {
			return nil, reportError("data should be InlineObject35")
		}
		localVarPostBody = &localVarOptionalData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesNotificationTemplatesSuccessListOpts Optional parameters for the method 'JobTemplatesJobTemplatesNotificationTemplatesSuccessList'
type JobTemplatesJobTemplatesNotificationTemplatesSuccessListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesNotificationTemplatesSuccessList  List Notification Templates for a Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesNotificationTemplatesSuccessListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesNotificationTemplatesSuccessListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesObjectRolesListOpts Optional parameters for the method 'JobTemplatesJobTemplatesObjectRolesList'
type JobTemplatesJobTemplatesObjectRolesListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesObjectRolesList  List Roles for a Job Template
 Make a GET request to this resource to retrieve a list of roles associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of roles found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more role records.    ## Results  Each role data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this role. (integer) * &#x60;type&#x60;: Data type for this role. (choice) * &#x60;url&#x60;: URL for this role. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;name&#x60;: Name of this role. (field) * &#x60;description&#x60;: Optional description of this role. (field)    ## Sorting  To specify that roles are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesObjectRolesListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesObjectRolesList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesObjectRolesListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/object_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesPartialUpdateOpts Optional parameters for the method 'JobTemplatesJobTemplatesPartialUpdate'
type JobTemplatesJobTemplatesPartialUpdateOpts struct {
    Search optional.String
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesPartialUpdate  Update a Job Template
 Make a PUT or PATCH request to this resource to update this job template.  The following fields may be modified:          * &#x60;name&#x60;: Name of this job template. (string, required) * &#x60;description&#x60;: Optional description of this job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run (default)     - &#x60;check&#x60;: Check * &#x60;inventory&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;project&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;playbook&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;forks&#x60;:  (integer, default&#x3D;&#x60;0&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal) (default)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;force_handlers&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;start_at_task&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer, default&#x3D;&#x60;0&#x60;) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default&#x3D;&#x60;False&#x60;)      * &#x60;host_config_key&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_diff_mode_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_skip_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_job_type_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_verbosity_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_credential_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;become_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;custom_virtualenv&#x60;: Local absolute file path containing a custom Python virtualenv to use (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_slice_count&#x60;: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default&#x3D;&#x60;1&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)         For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesPartialUpdateOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesPartialUpdate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesPartialUpdateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesReadOpts Optional parameters for the method 'JobTemplatesJobTemplatesRead'
type JobTemplatesJobTemplatesReadOpts struct {
    Search optional.String
}

/*
JobTemplatesJobTemplatesRead  Retrieve a Job Template
 Make GET request to this resource to retrieve a single job template record containing the following fields:  * &#x60;id&#x60;: Database ID for this job template. (integer) * &#x60;type&#x60;: Data type for this job template. (choice) * &#x60;url&#x60;: URL for this job template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this job template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this job template was last modified. (datetime) * &#x60;name&#x60;: Name of this job template. (string) * &#x60;description&#x60;: Optional description of this job template. (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;inventory&#x60;:  (id) * &#x60;project&#x60;:  (id) * &#x60;playbook&#x60;:  (string) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string) * &#x60;forks&#x60;:  (integer) * &#x60;limit&#x60;:  (string) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json) * &#x60;job_tags&#x60;:  (string) * &#x60;force_handlers&#x60;:  (boolean) * &#x60;skip_tags&#x60;:  (string) * &#x60;start_at_task&#x60;:  (string) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean) * &#x60;organization&#x60;: The organization used to determine access to this template. (id) * &#x60;last_job_run&#x60;:  (datetime) * &#x60;last_job_failed&#x60;:  (boolean) * &#x60;next_job_run&#x60;:  (datetime) * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled     - &#x60;never updated&#x60;: Never Updated * &#x60;host_config_key&#x60;:  (string) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean) * &#x60;ask_diff_mode_on_launch&#x60;:  (boolean) * &#x60;ask_variables_on_launch&#x60;:  (boolean) * &#x60;ask_limit_on_launch&#x60;:  (boolean) * &#x60;ask_tags_on_launch&#x60;:  (boolean) * &#x60;ask_skip_tags_on_launch&#x60;:  (boolean) * &#x60;ask_job_type_on_launch&#x60;:  (boolean) * &#x60;ask_verbosity_on_launch&#x60;:  (boolean) * &#x60;ask_inventory_on_launch&#x60;:  (boolean) * &#x60;ask_credential_on_launch&#x60;:  (boolean) * &#x60;survey_enabled&#x60;:  (boolean) * &#x60;become_enabled&#x60;:  (boolean) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;custom_virtualenv&#x60;: Local absolute file path containing a custom Python virtualenv to use (string) * &#x60;job_slice_count&#x60;: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesReadOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesRead(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesReadOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSchedulesCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesSchedulesCreate'
type JobTemplatesJobTemplatesSchedulesCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesSchedulesCreate  Create a Schedule for a Job Template
 Make a POST request to this resource with the following schedule fields to create a new schedule associated with this job template.   * &#x60;rrule&#x60;: A value representing the schedules iCal recurrence rule. (string, required)        * &#x60;name&#x60;: Name of this schedule. (string, required) * &#x60;description&#x60;: Optional description of this schedule. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;extra_data&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;diff_mode&#x60;:  (boolean, default&#x3D;&#x60;None&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug)  * &#x60;enabled&#x60;: Enables processing of this schedule. (boolean, default&#x3D;&#x60;True&#x60;)            POST requests to this resource must include a proper &#x60;rrule&#x60; value following a particular format and conforming to subset of allowed rules.  The following lists the expected format and details of our rrules:  * DTSTART is required and must follow the following format: DTSTART:YYYYMMDDTHHMMSSZ * DTSTART is expected to be in UTC * INTERVAL is required * SECONDLY is not supported * TZID is not supported * RRULE must precede the rule statements * BYDAY is supported but not BYDAY with a numerical prefix * BYYEARDAY and BYWEEKNO are not supported * Only one rrule statement per schedule is supported * COUNT must be &lt; 1000  Here are some example rrules:      \&quot;DTSTART:20500331T055000Z RRULE:FREQ&#x3D;MINUTELY;INTERVAL&#x3D;10;COUNT&#x3D;5\&quot;     \&quot;DTSTART:20240331T075000Z RRULE:FREQ&#x3D;DAILY;INTERVAL&#x3D;1;COUNT&#x3D;1\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;MINUTELY;INTERVAL&#x3D;1;UNTIL&#x3D;20230401T075000Z\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;1;BYDAY&#x3D;MO,WE,FR\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;5;BYDAY&#x3D;MO\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;1;BYMONTHDAY&#x3D;6\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;1;BYSETPOS&#x3D;4;BYDAY&#x3D;SU\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;1;BYSETPOS&#x3D;-1;BYDAY&#x3D;MO,TU,WE,TH,FR\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;1;BYSETPOS&#x3D;-1;BYDAY&#x3D;MO,TU,WE,TH,FR,SA,SU\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;1;BYMONTH&#x3D;4;BYMONTHDAY&#x3D;1\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;1;BYSETPOS&#x3D;-1;BYMONTH&#x3D;8;BYDAY&#x3D;SU\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;1;UNTIL&#x3D;20230401T075000Z;BYDAY&#x3D;MO,WE,FR\&quot;     \&quot;DTSTART:20140331T075000Z RRULE:FREQ&#x3D;HOURLY;INTERVAL&#x3D;1;UNTIL&#x3D;20230610T075000Z\&quot;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSchedulesCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSchedulesCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSchedulesListOpts Optional parameters for the method 'JobTemplatesJobTemplatesSchedulesList'
type JobTemplatesJobTemplatesSchedulesListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesSchedulesList  List Schedules for a Job Template
 Make a GET request to this resource to retrieve a list of schedules associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of schedules found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more schedule records.    ## Results  Each schedule data structure includes the following fields:  * &#x60;rrule&#x60;: A value representing the schedules iCal recurrence rule. (string) * &#x60;id&#x60;: Database ID for this schedule. (integer) * &#x60;type&#x60;: Data type for this schedule. (choice) * &#x60;url&#x60;: URL for this schedule. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this schedule was created. (datetime) * &#x60;modified&#x60;: Timestamp when this schedule was last modified. (datetime) * &#x60;name&#x60;: Name of this schedule. (string) * &#x60;description&#x60;: Optional description of this schedule. (string) * &#x60;extra_data&#x60;:  (json) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;scm_branch&#x60;:  (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string) * &#x60;skip_tags&#x60;:  (string) * &#x60;limit&#x60;:  (string) * &#x60;diff_mode&#x60;:  (boolean) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;unified_job_template&#x60;:  (id) * &#x60;enabled&#x60;: Enables processing of this schedule. (boolean) * &#x60;dtstart&#x60;: The first occurrence of the schedule occurs on or after this time. (datetime) * &#x60;dtend&#x60;: The last occurrence of the schedule occurs before this time, aftewards the schedule expires. (datetime) * &#x60;next_run&#x60;: The next time that the scheduled action will run. (datetime) * &#x60;timezone&#x60;:  (field) * &#x60;until&#x60;:  (field)    ## Sorting  To specify that schedules are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSchedulesListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSchedulesListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSliceWorkflowJobsCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesSliceWorkflowJobsCreate'
type JobTemplatesJobTemplatesSliceWorkflowJobsCreateOpts struct {
    Data optional.Interface
}

/*
JobTemplatesJobTemplatesSliceWorkflowJobsCreate  Create a Workflow Job for a Job Template
 Make a POST request to this resource with the following workflow job fields to create a new workflow job associated with this job template.          * &#x60;name&#x60;: Name of this workflow job. (string, required) * &#x60;description&#x60;: Optional description of this workflow job. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)          * &#x60;workflow_job_template&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;)  * &#x60;is_sliced_job&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;) * &#x60;webhook_guid&#x60;: Unique identifier of the event that triggered this webhook (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSliceWorkflowJobsCreateOpts - Optional Parameters:
 * @param "Data" (optional.Interface of InlineObject36) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSliceWorkflowJobsCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/slice_workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(InlineObject36)
		if !localVarOptionalDataok {
			return nil, reportError("data should be InlineObject36")
		}
		localVarPostBody = &localVarOptionalData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSliceWorkflowJobsListOpts Optional parameters for the method 'JobTemplatesJobTemplatesSliceWorkflowJobsList'
type JobTemplatesJobTemplatesSliceWorkflowJobsListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesSliceWorkflowJobsList  List Workflow Jobs for a Job Template
 Make a GET request to this resource to retrieve a list of workflow jobs associated with the selected job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of workflow jobs found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more workflow job records.    ## Results  Each workflow job data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this workflow job. (integer) * &#x60;type&#x60;: Data type for this workflow job. (choice) * &#x60;url&#x60;: URL for this workflow job. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this workflow job was created. (datetime) * &#x60;modified&#x60;: Timestamp when this workflow job was last modified. (datetime) * &#x60;name&#x60;: Name of this workflow job. (string) * &#x60;description&#x60;: Optional description of this workflow job. (string) * &#x60;unified_job_template&#x60;:  (id) * &#x60;launch_type&#x60;:  (choice)     - &#x60;manual&#x60;: Manual     - &#x60;relaunch&#x60;: Relaunch     - &#x60;callback&#x60;: Callback     - &#x60;scheduled&#x60;: Scheduled     - &#x60;dependency&#x60;: Dependency     - &#x60;workflow&#x60;: Workflow     - &#x60;webhook&#x60;: Webhook     - &#x60;sync&#x60;: Sync     - &#x60;scm&#x60;: SCM Update * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled * &#x60;failed&#x60;:  (boolean) * &#x60;started&#x60;: The date and time the job was queued for starting. (datetime) * &#x60;finished&#x60;: The date and time the job finished execution. (datetime) * &#x60;canceled_on&#x60;: The date and time when the cancel request was sent. (datetime) * &#x60;elapsed&#x60;: Elapsed time in seconds that the job ran. (decimal) * &#x60;job_explanation&#x60;: A status field to indicate the state of the job if it wasn&amp;#39;t able to run and capture stdout (string) * &#x60;workflow_job_template&#x60;:  (id) * &#x60;extra_vars&#x60;:  (json) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;job_template&#x60;: If automatically created for a sliced job run, the job template the workflow job was created from. (id) * &#x60;is_sliced_job&#x60;:  (boolean) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;limit&#x60;:  (string) * &#x60;scm_branch&#x60;:  (string) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id) * &#x60;webhook_guid&#x60;: Unique identifier of the event that triggered this webhook (string)    ## Sorting  To specify that workflow jobs are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSliceWorkflowJobsListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSliceWorkflowJobsListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/slice_workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSurveySpecCreateOpts Optional parameters for the method 'JobTemplatesJobTemplatesSurveySpecCreate'
type JobTemplatesJobTemplatesSurveySpecCreateOpts struct {
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesSurveySpecCreate POST requests to this resource should include the full specification for a Job Template's Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSurveySpecCreateOpts - Optional Parameters:
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecCreate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSurveySpecCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSurveySpecDeleteOpts Optional parameters for the method 'JobTemplatesJobTemplatesSurveySpecDelete'
type JobTemplatesJobTemplatesSurveySpecDeleteOpts struct {
    Search optional.String
}

/*
JobTemplatesJobTemplatesSurveySpecDelete POST requests to this resource should include the full specification for a Job Template's Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSurveySpecDeleteOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecDelete(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSurveySpecDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesSurveySpecListOpts Optional parameters for the method 'JobTemplatesJobTemplatesSurveySpecList'
type JobTemplatesJobTemplatesSurveySpecListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesSurveySpecList POST requests to this resource should include the full specification for a Job Template's Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesSurveySpecListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesSurveySpecListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesUpdateOpts Optional parameters for the method 'JobTemplatesJobTemplatesUpdate'
type JobTemplatesJobTemplatesUpdateOpts struct {
    Search optional.String
    Data optional.Map[string]interface{}
}

/*
JobTemplatesJobTemplatesUpdate  Update a Job Template
 Make a PUT or PATCH request to this resource to update this job template.  The following fields may be modified:          * &#x60;name&#x60;: Name of this job template. (string, required) * &#x60;description&#x60;: Optional description of this job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;run&#x60;: Run (default)     - &#x60;check&#x60;: Check * &#x60;inventory&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;project&#x60;:  (id, default&#x3D;&#x60;&#x60;) * &#x60;playbook&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;forks&#x60;:  (integer, default&#x3D;&#x60;0&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;0&#x60;: 0 (Normal) (default)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;force_handlers&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;start_at_task&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;timeout&#x60;: The amount of time (in seconds) to run before the task is canceled. (integer, default&#x3D;&#x60;0&#x60;) * &#x60;use_fact_cache&#x60;: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default&#x3D;&#x60;False&#x60;)      * &#x60;host_config_key&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_diff_mode_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_skip_tags_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_job_type_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_verbosity_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_credential_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;become_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;diff_mode&#x60;: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;custom_virtualenv&#x60;: Local absolute file path containing a custom Python virtualenv to use (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_slice_count&#x60;: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default&#x3D;&#x60;1&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)       For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesUpdateOpts - Optional Parameters:
 * @param "Search" (optional.String) -  A search term.
 * @param "Data" (optional.Map[string]interface{}) - 
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesUpdate(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesUpdateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = localVarOptionals.Data.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
JobTemplatesJobTemplatesWebhookKeyCreate Method for JobTemplatesJobTemplatesWebhookKeyCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyCreate(ctx _context.Context, id string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// JobTemplatesJobTemplatesWebhookKeyListOpts Optional parameters for the method 'JobTemplatesJobTemplatesWebhookKeyList'
type JobTemplatesJobTemplatesWebhookKeyListOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    Search optional.String
}

/*
JobTemplatesJobTemplatesWebhookKeyList Method for JobTemplatesJobTemplatesWebhookKeyList
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *JobTemplatesJobTemplatesWebhookKeyListOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  A page number within the paginated result set.
 * @param "PageSize" (optional.Int32) -  Number of results to return per page.
 * @param "Search" (optional.String) -  A search term.
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyList(ctx _context.Context, id string, localVarOptionals *JobTemplatesJobTemplatesWebhookKeyListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
