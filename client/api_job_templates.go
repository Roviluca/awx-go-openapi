/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version:
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// JobTemplatesApiService JobTemplatesApi service
type JobTemplatesApiService service

type ApiJobTemplatesJobTemplatesAccessListListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesAccessListListRequest) Page(page int32) ApiJobTemplatesJobTemplatesAccessListListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesAccessListListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesAccessListListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesAccessListListRequest) Search(search string) ApiJobTemplatesJobTemplatesAccessListListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesAccessListListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesAccessListListExecute(r)
}

/*
 * JobTemplatesJobTemplatesAccessListList  List Users
 *
Make a GET request to this resource to retrieve the list of
users.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of users
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more user records.

## Results

Each user data structure includes the following fields:

* `id`: Database ID for this user. (integer)
* `type`: Data type for this user. (choice)
* `url`: URL for this user. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this user was created. (datetime)
* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string)
* `first_name`:  (string)
* `last_name`:  (string)
* `email`:  (string)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean)
* `is_system_auditor`:  (boolean)

* `ldap_dn`:  (string)
* `last_login`:  (datetime)
* `external_account`: Set if the account is managed by an external service (field)



## Sorting

To specify that users are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=username

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-username

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=username,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesAccessListListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesAccessListList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesAccessListListRequest {
	return ApiJobTemplatesJobTemplatesAccessListListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesAccessListListExecute(r ApiJobTemplatesJobTemplatesAccessListListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesAccessListList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/access_list/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesActivityStreamListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesActivityStreamListRequest) Page(page int32) ApiJobTemplatesJobTemplatesActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesActivityStreamListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesActivityStreamListRequest) Search(search string) ApiJobTemplatesJobTemplatesActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesActivityStreamListExecute(r)
}

/*
 * JobTemplatesJobTemplatesActivityStreamList  List Activity Streams for a Job Template
 *
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesActivityStreamListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesActivityStreamList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesActivityStreamListRequest {
	return ApiJobTemplatesJobTemplatesActivityStreamListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesActivityStreamListExecute(r ApiJobTemplatesJobTemplatesActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCallbackCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesCallbackCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesCallbackCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesCallbackCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCallbackCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesCallbackCreate The job template callback allows for ephemeral hosts to launch a new job.
 *
Configure a host to POST to this resource, passing the `host_config_key`
parameter, to start a new job limited to only the requesting host.  In the
examples below, replace the `N` parameter with the `id` of the job template
and the `HOST_CONFIG_KEY` with the `host_config_key` associated with the
job template.

For example, using curl:

    curl -H "Content-Type: application/json" -d '{"host_config_key": "HOST_CONFIG_KEY"}'  http://server/api/v2/job_templates/N/callback/

Or using wget:

    wget -O /dev/null --post-data='{"host_config_key": "HOST_CONFIG_KEY"}' --header=Content-Type:application/json http://server/api/v2/job_templates/N/callback/

You may also pass `extra_vars` to the callback:

    curl -H "Content-Type: application/json" -d '{"host_config_key": "HOST_CONFIG_KEY", "extra_vars": {"key": "value"}}'  http://server/api/v2/job_templates/N/callback/

The response will return status 202 if the request is valid, 403 for an
invalid host config key, or 400 if the host cannot be determined from the
address making the request.

_(New in Ansible Tower 2.0.0)_  If the associated inventory has the
`update_on_launch` flag set and if the `update_cache_timeout` has expired, the
callback will perform an inventory sync to find a matching host.

A GET request may be used to verify that the correct host will be selected.
This request must authenticate as a valid user with permission to edit the
job template.  For example:

    curl http://user:password@server/api/v2/job_templates/N/callback/

The response will include the host config key as well as the host name(s)
that would match the request:

    {
        "host_config_key": "HOST_CONFIG_KEY",
        "matching_hosts": ["hostname"]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCallbackCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCallbackCreateRequest {
	return ApiJobTemplatesJobTemplatesCallbackCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackCreateExecute(r ApiJobTemplatesJobTemplatesCallbackCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCallbackCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/callback/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCallbackListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesCallbackListRequest) Page(page int32) ApiJobTemplatesJobTemplatesCallbackListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesCallbackListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesCallbackListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesCallbackListRequest) Search(search string) ApiJobTemplatesJobTemplatesCallbackListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesCallbackListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCallbackListExecute(r)
}

/*
 * JobTemplatesJobTemplatesCallbackList The job template callback allows for ephemeral hosts to launch a new job.
 *
Configure a host to POST to this resource, passing the `host_config_key`
parameter, to start a new job limited to only the requesting host.  In the
examples below, replace the `N` parameter with the `id` of the job template
and the `HOST_CONFIG_KEY` with the `host_config_key` associated with the
job template.

For example, using curl:

    curl -H "Content-Type: application/json" -d '{"host_config_key": "HOST_CONFIG_KEY"}'  http://server/api/v2/job_templates/N/callback/

Or using wget:

    wget -O /dev/null --post-data='{"host_config_key": "HOST_CONFIG_KEY"}' --header=Content-Type:application/json http://server/api/v2/job_templates/N/callback/

You may also pass `extra_vars` to the callback:

    curl -H "Content-Type: application/json" -d '{"host_config_key": "HOST_CONFIG_KEY", "extra_vars": {"key": "value"}}'  http://server/api/v2/job_templates/N/callback/

The response will return status 202 if the request is valid, 403 for an
invalid host config key, or 400 if the host cannot be determined from the
address making the request.

_(New in Ansible Tower 2.0.0)_  If the associated inventory has the
`update_on_launch` flag set and if the `update_cache_timeout` has expired, the
callback will perform an inventory sync to find a matching host.

A GET request may be used to verify that the correct host will be selected.
This request must authenticate as a valid user with permission to edit the
job template.  For example:

    curl http://user:password@server/api/v2/job_templates/N/callback/

The response will include the host config key as well as the host name(s)
that would match the request:

    {
        "host_config_key": "HOST_CONFIG_KEY",
        "matching_hosts": ["hostname"]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCallbackListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCallbackListRequest {
	return ApiJobTemplatesJobTemplatesCallbackListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCallbackListExecute(r ApiJobTemplatesJobTemplatesCallbackListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCallbackList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/callback/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCopyCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *InlineObject32
}

func (r ApiJobTemplatesJobTemplatesCopyCreateRequest) Data(data InlineObject32) ApiJobTemplatesJobTemplatesCopyCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesCopyCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCopyCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesCopyCreate Method for JobTemplatesJobTemplatesCopyCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCopyCreateRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCopyCreateRequest {
	return ApiJobTemplatesJobTemplatesCopyCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyCreateExecute(r ApiJobTemplatesJobTemplatesCopyCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCopyCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCopyListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesCopyListRequest) Page(page int32) ApiJobTemplatesJobTemplatesCopyListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesCopyListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesCopyListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesCopyListRequest) Search(search string) ApiJobTemplatesJobTemplatesCopyListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesCopyListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCopyListExecute(r)
}

/*
 * JobTemplatesJobTemplatesCopyList Method for JobTemplatesJobTemplatesCopyList
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCopyListRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCopyListRequest {
	return ApiJobTemplatesJobTemplatesCopyListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCopyListExecute(r ApiJobTemplatesJobTemplatesCopyListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCopyList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesCreate  Create a Job Template
 *
Make a POST request to this resource with the following job template
fields to create a new job template:









* `name`: Name of this job template. (string, required)
* `description`: Optional description of this job template. (string, default=`""`)
* `job_type`:  (choice)
    - `run`: Run (default)
    - `check`: Check
* `inventory`:  (id, default=``)
* `project`:  (id, default=``)
* `playbook`:  (string, default=`""`)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default=`""`)
* `forks`:  (integer, default=`0`)
* `limit`:  (string, default=`""`)
* `verbosity`:  (choice)
    - `0`: 0 (Normal) (default)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json, default=``)
* `job_tags`:  (string, default=`""`)
* `force_handlers`:  (boolean, default=`False`)
* `skip_tags`:  (string, default=`""`)
* `start_at_task`:  (string, default=`""`)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer, default=`0`)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default=`False`)





* `host_config_key`:  (string, default=`""`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_diff_mode_on_launch`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `ask_tags_on_launch`:  (boolean, default=`False`)
* `ask_skip_tags_on_launch`:  (boolean, default=`False`)
* `ask_job_type_on_launch`:  (boolean, default=`False`)
* `ask_verbosity_on_launch`:  (boolean, default=`False`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_credential_on_launch`:  (boolean, default=`False`)
* `survey_enabled`:  (boolean, default=`False`)
* `become_enabled`:  (boolean, default=`False`)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default=`1`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiJobTemplatesJobTemplatesCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCreate(ctx _context.Context) ApiJobTemplatesJobTemplatesCreateRequest {
	return ApiJobTemplatesJobTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCreateExecute(r ApiJobTemplatesJobTemplatesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCredentialsCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesCredentialsCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesCredentialsCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesCredentialsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCredentialsCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesCredentialsCreate  Create a Credential for a Job Template
 *
Make a POST request to this resource with the following credential
fields to create a new credential associated with this
job template.









* `name`: Name of this credential. (string, required)
* `description`: Optional description of this credential. (string, default=`""`)
* `organization`:  (id, default=`None`)
* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id, required)

* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json, default=`{}`)











# Add Credentials for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing credential with this job template.

# Remove Credentials from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the credential from this job template
 without deleting the credential.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCredentialsCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCredentialsCreateRequest {
	return ApiJobTemplatesJobTemplatesCredentialsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsCreateExecute(r ApiJobTemplatesJobTemplatesCredentialsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCredentialsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesCredentialsListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesCredentialsListRequest) Page(page int32) ApiJobTemplatesJobTemplatesCredentialsListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesCredentialsListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesCredentialsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesCredentialsListRequest) Search(search string) ApiJobTemplatesJobTemplatesCredentialsListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesCredentialsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesCredentialsListExecute(r)
}

/*
 * JobTemplatesJobTemplatesCredentialsList  List Credentials for a Job Template
 *
Make a GET request to this resource to retrieve a list of
credentials associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of credentials
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more credential records.

## Results

Each credential data structure includes the following fields:

* `id`: Database ID for this credential. (integer)
* `type`: Data type for this credential. (choice)
* `url`: URL for this credential. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this credential was created. (datetime)
* `modified`: Timestamp when this credential was last modified. (datetime)
* `name`: Name of this credential. (string)
* `description`: Optional description of this credential. (string)
* `organization`:  (id)
* `credential_type`: Specify the type of credential you want to create. Refer to the Ansible Tower documentation for details on each type. (id)
* `managed_by_tower`:  (boolean)
* `inputs`: Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax. (json)
* `kind`:  (field)
* `cloud`:  (field)
* `kubernetes`:  (field)



## Sorting

To specify that credentials are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesCredentialsListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesCredentialsListRequest {
	return ApiJobTemplatesJobTemplatesCredentialsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesCredentialsListExecute(r ApiJobTemplatesJobTemplatesCredentialsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesCredentialsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesDeleteRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
}

func (r ApiJobTemplatesJobTemplatesDeleteRequest) Search(search string) ApiJobTemplatesJobTemplatesDeleteRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesDeleteExecute(r)
}

/*
 * JobTemplatesJobTemplatesDelete  Delete a Job Template
 *
Make a DELETE request to this resource to delete this job template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesDeleteRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesDelete(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesDeleteRequest {
	return ApiJobTemplatesJobTemplatesDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesDeleteExecute(r ApiJobTemplatesJobTemplatesDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesGithubCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
}

func (r ApiJobTemplatesJobTemplatesGithubCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesGithubCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesGithubCreate Method for JobTemplatesJobTemplatesGithubCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesGithubCreateRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGithubCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesGithubCreateRequest {
	return ApiJobTemplatesJobTemplatesGithubCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGithubCreateExecute(r ApiJobTemplatesJobTemplatesGithubCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesGithubCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/github/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesGitlabCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
}

func (r ApiJobTemplatesJobTemplatesGitlabCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesGitlabCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesGitlabCreate Method for JobTemplatesJobTemplatesGitlabCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesGitlabCreateRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGitlabCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesGitlabCreateRequest {
	return ApiJobTemplatesJobTemplatesGitlabCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesGitlabCreateExecute(r ApiJobTemplatesJobTemplatesGitlabCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesGitlabCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/gitlab/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesInstanceGroupsCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesInstanceGroupsCreate  Create an Instance Group for a Job Template
 *
Make a POST request to this resource with the following instance group
fields to create a new instance group associated with this
job template.






* `name`: Name of this instance group. (string, required)













* `credential`:  (id, default=``)
* `policy_instance_percentage`: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer, default=`0`)
* `policy_instance_minimum`: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer, default=`0`)
* `policy_instance_list`: List of exact-match Instances that will be assigned to this group (json, default=``)
* `pod_spec_override`:  (string, default=`""`)









# Add Instance Groups for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing instance group with this job template.

# Remove Instance Groups from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the instance group from this job template
 without deleting the instance group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest {
	return ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsCreateExecute(r ApiJobTemplatesJobTemplatesInstanceGroupsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesInstanceGroupsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesInstanceGroupsListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesInstanceGroupsListRequest) Page(page int32) ApiJobTemplatesJobTemplatesInstanceGroupsListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesInstanceGroupsListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesInstanceGroupsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesInstanceGroupsListRequest) Search(search string) ApiJobTemplatesJobTemplatesInstanceGroupsListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesInstanceGroupsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesInstanceGroupsListExecute(r)
}

/*
 * JobTemplatesJobTemplatesInstanceGroupsList  List Instance Groups for a Job Template
 *
Make a GET request to this resource to retrieve a list of
instance groups associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of instance groups
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more instance group records.

## Results

Each instance group data structure includes the following fields:

* `id`: Database ID for this instance group. (integer)
* `type`: Data type for this instance group. (choice)
* `url`: URL for this instance group. (string)
* `related`: Data structure with URLs of related resources. (object)
* `name`: Name of this instance group. (string)
* `created`: Timestamp when this instance group was created. (datetime)
* `modified`: Timestamp when this instance group was last modified. (datetime)
* `capacity`:  (field)
* `committed_capacity`:  (field)
* `consumed_capacity`:  (field)
* `percent_capacity_remaining`:  (field)
* `jobs_running`: Count of jobs in the running or waiting state that are targeted for this instance group (integer)
* `jobs_total`: Count of all jobs that target this instance group (integer)
* `instances`:  (field)
* `controller`: Instance Group to remotely control this group. (id)
* `is_controller`: Indicates whether instance group controls any other group (boolean)
* `is_isolated`: Indicates whether instances in this group are isolated.Isolated groups have a designated controller group. (boolean)
* `is_containerized`: Indicates whether instances in this group are containerized.Containerized groups have a designated Openshift or Kubernetes cluster. (boolean)
* `credential`:  (id)
* `policy_instance_percentage`: Minimum percentage of all instances that will be automatically assigned to this group when new instances come online. (integer)
* `policy_instance_minimum`: Static minimum number of Instances that will be automatically assign to this group when new instances come online. (integer)
* `policy_instance_list`: List of exact-match Instances that will be assigned to this group (json)
* `pod_spec_override`:  (string)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)



## Sorting

To specify that instance groups are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesInstanceGroupsListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesInstanceGroupsListRequest {
	return ApiJobTemplatesJobTemplatesInstanceGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesInstanceGroupsListExecute(r ApiJobTemplatesJobTemplatesInstanceGroupsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesInstanceGroupsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/instance_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesJobsListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesJobsListRequest) Page(page int32) ApiJobTemplatesJobTemplatesJobsListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesJobsListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesJobsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesJobsListRequest) Search(search string) ApiJobTemplatesJobTemplatesJobsListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesJobsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesJobsListExecute(r)
}

/*
 * JobTemplatesJobTemplatesJobsList  List Jobs for a Job Template
 *
Make a GET request to this resource to retrieve a list of
jobs associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of jobs
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more job records.

## Results

Each job data structure includes the following fields:

* `id`: Database ID for this job. (integer)
* `type`: Data type for this job. (choice)
* `url`: URL for this job. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this job was created. (datetime)
* `modified`: Timestamp when this job was last modified. (datetime)
* `name`: Name of this job. (string)
* `description`: Optional description of this job. (string)
* `unified_job_template`:  (id)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `execution_node`: The node the job executed on. (string)
* `controller_node`: The instance that managed the isolated execution environment. (string)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
    - `scan`: Scan
* `inventory`:  (id)
* `project`:  (id)
* `playbook`:  (string)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string)
* `forks`:  (integer)
* `limit`:  (string)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json)
* `job_tags`:  (string)
* `force_handlers`:  (boolean)
* `skip_tags`:  (string)
* `start_at_task`:  (string)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean)
* `organization`: The organization used to determine access to this unified job. (id)
* `job_template`:  (id)
* `passwords_needed_to_start`:  (field)
* `allow_simultaneous`:  (boolean)
* `artifacts`:  (json)
* `scm_revision`: The SCM Revision from the Project used for this job, if available (string)
* `instance_group`: The Instance group the job was run under (id)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean)
* `job_slice_number`: If part of a sliced job, the ID of the inventory slice operated on. If not part of sliced job, parameter is not used. (integer)
* `job_slice_count`: If ran as part of sliced jobs, the total number of slices. If 1, job is not part of a sliced job. (integer)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string)



## Sorting

To specify that jobs are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesJobsListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesJobsList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesJobsListRequest {
	return ApiJobTemplatesJobTemplatesJobsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesJobsListExecute(r ApiJobTemplatesJobTemplatesJobsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesJobsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesLabelsCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *InlineObject33
}

func (r ApiJobTemplatesJobTemplatesLabelsCreateRequest) Data(data InlineObject33) ApiJobTemplatesJobTemplatesLabelsCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesLabelsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesLabelsCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesLabelsCreate  Create a Label for a Job Template
 *
Make a POST request to this resource with the following label
fields to create a new label associated with this
job template.









* `name`: Name of this label. (string, required)
* `organization`: Organization this label belongs to. (id, required)








# Add Labels for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing label with this job template.

# Remove Labels from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the label from this job template
.




Labels not associated with any other resources are deleted. A label can become disassociated with a resource as a result of 3 events.

1. A label is explicitly disassociated with a related job template
2. A job is deleted with labels
3. A cleanup job deletes a job with labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesLabelsCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesLabelsCreateRequest {
	return ApiJobTemplatesJobTemplatesLabelsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsCreateExecute(r ApiJobTemplatesJobTemplatesLabelsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesLabelsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesLabelsListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesLabelsListRequest) Page(page int32) ApiJobTemplatesJobTemplatesLabelsListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesLabelsListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesLabelsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesLabelsListRequest) Search(search string) ApiJobTemplatesJobTemplatesLabelsListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesLabelsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesLabelsListExecute(r)
}

/*
 * JobTemplatesJobTemplatesLabelsList  List Labels for a Job Template
 *
Make a GET request to this resource to retrieve a list of
labels associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of labels
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more label records.

## Results

Each label data structure includes the following fields:

* `id`: Database ID for this label. (integer)
* `type`: Data type for this label. (choice)
* `url`: URL for this label. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this label was created. (datetime)
* `modified`: Timestamp when this label was last modified. (datetime)
* `name`: Name of this label. (string)
* `organization`: Organization this label belongs to. (id)



## Sorting

To specify that labels are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesLabelsListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesLabelsListRequest {
	return ApiJobTemplatesJobTemplatesLabelsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLabelsListExecute(r ApiJobTemplatesJobTemplatesLabelsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesLabelsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesLaunchCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesLaunchCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesLaunchCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesLaunchCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesLaunchCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesLaunchCreate Launch a Job Template
 *
Make a GET request to this resource to determine if the job_template can be
launched and whether any passwords are required to launch the job_template.
The response will include the following fields:

* `ask_variables_on_launch`: Flag indicating whether the job_template is
  configured to prompt for variables upon launch (boolean, read-only)
* `ask_tags_on_launch`: Flag indicating whether the job_template is
  configured to prompt for tags upon launch (boolean, read-only)
* `ask_skip_tags_on_launch`: Flag indicating whether the job_template is
  configured to prompt for skip_tags upon launch (boolean, read-only)
* `ask_job_type_on_launch`: Flag indicating whether the job_template is
  configured to prompt for job_type upon launch (boolean, read-only)
* `ask_limit_on_launch`: Flag indicating whether the job_template is
  configured to prompt for limit upon launch (boolean, read-only)
* `ask_inventory_on_launch`: Flag indicating whether the job_template is
  configured to prompt for inventory upon launch (boolean, read-only)
* `ask_credential_on_launch`: Flag indicating whether the job_template is
  configured to prompt for credential upon launch (boolean, read-only)
* `can_start_without_user_input`: Flag indicating if the job_template can be
  launched without user-input (boolean, read-only)
* `passwords_needed_to_start`: Password names required to launch the
  job_template (array, read-only)
* `variables_needed_to_start`: Required variable names required to launch the
  job_template (array, read-only)
* `survey_enabled`: Flag indicating whether the job_template has an enabled
  survey (boolean, read-only)
* `inventory_needed_to_start`: Flag indicating the presence of an inventory
  associated with the job template.  If not then one should be supplied when
  launching the job (boolean, read-only)

Make a POST request to this resource to launch the job_template. If any
passwords, inventory, or extra variables (extra_vars) are required, they must
be passed via POST data, with extra_vars given as a YAML or JSON string and
escaped parentheses. If the `inventory_needed_to_start` is `True` then the
`inventory` is required.

If successful, the response status code will be 201.  If any required passwords
are not provided, a 400 status code will be returned.  If the job cannot be
launched, a 405 status code will be returned. If the provided credential or
inventory are not allowed to be used by the user, then a 403 status code will
be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesLaunchCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesLaunchCreateRequest {
	return ApiJobTemplatesJobTemplatesLaunchCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchCreateExecute(r ApiJobTemplatesJobTemplatesLaunchCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesLaunchCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesLaunchReadRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
}

func (r ApiJobTemplatesJobTemplatesLaunchReadRequest) Search(search string) ApiJobTemplatesJobTemplatesLaunchReadRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesLaunchReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesLaunchReadExecute(r)
}

/*
 * JobTemplatesJobTemplatesLaunchRead Launch a Job Template
 *
Make a GET request to this resource to determine if the job_template can be
launched and whether any passwords are required to launch the job_template.
The response will include the following fields:

* `ask_variables_on_launch`: Flag indicating whether the job_template is
  configured to prompt for variables upon launch (boolean, read-only)
* `ask_tags_on_launch`: Flag indicating whether the job_template is
  configured to prompt for tags upon launch (boolean, read-only)
* `ask_skip_tags_on_launch`: Flag indicating whether the job_template is
  configured to prompt for skip_tags upon launch (boolean, read-only)
* `ask_job_type_on_launch`: Flag indicating whether the job_template is
  configured to prompt for job_type upon launch (boolean, read-only)
* `ask_limit_on_launch`: Flag indicating whether the job_template is
  configured to prompt for limit upon launch (boolean, read-only)
* `ask_inventory_on_launch`: Flag indicating whether the job_template is
  configured to prompt for inventory upon launch (boolean, read-only)
* `ask_credential_on_launch`: Flag indicating whether the job_template is
  configured to prompt for credential upon launch (boolean, read-only)
* `can_start_without_user_input`: Flag indicating if the job_template can be
  launched without user-input (boolean, read-only)
* `passwords_needed_to_start`: Password names required to launch the
  job_template (array, read-only)
* `variables_needed_to_start`: Required variable names required to launch the
  job_template (array, read-only)
* `survey_enabled`: Flag indicating whether the job_template has an enabled
  survey (boolean, read-only)
* `inventory_needed_to_start`: Flag indicating the presence of an inventory
  associated with the job template.  If not then one should be supplied when
  launching the job (boolean, read-only)

Make a POST request to this resource to launch the job_template. If any
passwords, inventory, or extra variables (extra_vars) are required, they must
be passed via POST data, with extra_vars given as a YAML or JSON string and
escaped parentheses. If the `inventory_needed_to_start` is `True` then the
`inventory` is required.

If successful, the response status code will be 201.  If any required passwords
are not provided, a 400 status code will be returned.  If the job cannot be
launched, a 405 status code will be returned. If the provided credential or
inventory are not allowed to be used by the user, then a 403 status code will
be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesLaunchReadRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchRead(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesLaunchReadRequest {
	return ApiJobTemplatesJobTemplatesLaunchReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesLaunchReadExecute(r ApiJobTemplatesJobTemplatesLaunchReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesLaunchRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesListRequest) Page(page int32) ApiJobTemplatesJobTemplatesListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesListRequest) Search(search string) ApiJobTemplatesJobTemplatesListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesListExecute(r)
}

/*
 * JobTemplatesJobTemplatesList  List Job Templates
 *
Make a GET request to this resource to retrieve the list of
job templates.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of job templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more job template records.

## Results

Each job template data structure includes the following fields:

* `id`: Database ID for this job template. (integer)
* `type`: Data type for this job template. (choice)
* `url`: URL for this job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this job template was created. (datetime)
* `modified`: Timestamp when this job template was last modified. (datetime)
* `name`: Name of this job template. (string)
* `description`: Optional description of this job template. (string)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
* `inventory`:  (id)
* `project`:  (id)
* `playbook`:  (string)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string)
* `forks`:  (integer)
* `limit`:  (string)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json)
* `job_tags`:  (string)
* `force_handlers`:  (boolean)
* `skip_tags`:  (string)
* `start_at_task`:  (string)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean)
* `organization`: The organization used to determine access to this template. (id)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
* `host_config_key`:  (string)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_diff_mode_on_launch`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `ask_tags_on_launch`:  (boolean)
* `ask_skip_tags_on_launch`:  (boolean)
* `ask_job_type_on_launch`:  (boolean)
* `ask_verbosity_on_launch`:  (boolean)
* `ask_inventory_on_launch`:  (boolean)
* `ask_credential_on_launch`:  (boolean)
* `survey_enabled`:  (boolean)
* `become_enabled`:  (boolean)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean)
* `allow_simultaneous`:  (boolean)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)



## Sorting

To specify that job templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiJobTemplatesJobTemplatesListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesList(ctx _context.Context) ApiJobTemplatesJobTemplatesListRequest {
	return ApiJobTemplatesJobTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesListExecute(r ApiJobTemplatesJobTemplatesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *InlineObject34
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest) Data(data InlineObject34) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesErrorCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesErrorCreate  Create a Notification Template for a Job Template
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this job template.

# Remove Notification Templates from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorCreateExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesErrorCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest) Page(page int32) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest) Search(search string) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesErrorListExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesErrorList  List Notification Templates for a Job Template
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesErrorListExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesErrorListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesErrorList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesStartedCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesStartedCreate  Create a Notification Template for a Job Template
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this job template.

# Remove Notification Templates from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedCreateExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesStartedCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest) Page(page int32) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest) Search(search string) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesStartedListExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesStartedList  List Notification Templates for a Job Template
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesStartedListExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesStartedListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesStartedList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *InlineObject35
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest) Data(data InlineObject35) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate  Create a Notification Template for a Job Template
 *
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this job template.

# Remove Notification Templates from this Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessCreateExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesSuccessCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest) Page(page int32) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest) Search(search string) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesNotificationTemplatesSuccessListExecute(r)
}

/*
 * JobTemplatesJobTemplatesNotificationTemplatesSuccessList  List Notification Templates for a Job Template
 *
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest {
	return ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesNotificationTemplatesSuccessListExecute(r ApiJobTemplatesJobTemplatesNotificationTemplatesSuccessListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesNotificationTemplatesSuccessList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesObjectRolesListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesObjectRolesListRequest) Page(page int32) ApiJobTemplatesJobTemplatesObjectRolesListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesObjectRolesListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesObjectRolesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesObjectRolesListRequest) Search(search string) ApiJobTemplatesJobTemplatesObjectRolesListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesObjectRolesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesObjectRolesListExecute(r)
}

/*
 * JobTemplatesJobTemplatesObjectRolesList  List Roles for a Job Template
 *
Make a GET request to this resource to retrieve a list of
roles associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of roles
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more role records.

## Results

Each role data structure includes the following fields:

* `id`: Database ID for this role. (integer)
* `type`: Data type for this role. (choice)
* `url`: URL for this role. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `name`: Name of this role. (field)
* `description`: Optional description of this role. (field)



## Sorting

To specify that roles are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesObjectRolesListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesObjectRolesList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesObjectRolesListRequest {
	return ApiJobTemplatesJobTemplatesObjectRolesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesObjectRolesListExecute(r ApiJobTemplatesJobTemplatesObjectRolesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesObjectRolesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/object_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesPartialUpdateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesPartialUpdateRequest) Search(search string) ApiJobTemplatesJobTemplatesPartialUpdateRequest {
	r.search = &search
	return r
}
func (r ApiJobTemplatesJobTemplatesPartialUpdateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesPartialUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesPartialUpdateExecute(r)
}

/*
 * JobTemplatesJobTemplatesPartialUpdate  Update a Job Template
 *
Make a PUT or PATCH request to this resource to update this
job template.  The following fields may be modified:









* `name`: Name of this job template. (string, required)
* `description`: Optional description of this job template. (string, default=`""`)
* `job_type`:  (choice)
    - `run`: Run (default)
    - `check`: Check
* `inventory`:  (id, default=``)
* `project`:  (id, default=``)
* `playbook`:  (string, default=`""`)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default=`""`)
* `forks`:  (integer, default=`0`)
* `limit`:  (string, default=`""`)
* `verbosity`:  (choice)
    - `0`: 0 (Normal) (default)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json, default=``)
* `job_tags`:  (string, default=`""`)
* `force_handlers`:  (boolean, default=`False`)
* `skip_tags`:  (string, default=`""`)
* `start_at_task`:  (string, default=`""`)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer, default=`0`)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default=`False`)





* `host_config_key`:  (string, default=`""`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_diff_mode_on_launch`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `ask_tags_on_launch`:  (boolean, default=`False`)
* `ask_skip_tags_on_launch`:  (boolean, default=`False`)
* `ask_job_type_on_launch`:  (boolean, default=`False`)
* `ask_verbosity_on_launch`:  (boolean, default=`False`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_credential_on_launch`:  (boolean, default=`False`)
* `survey_enabled`:  (boolean, default=`False`)
* `become_enabled`:  (boolean, default=`False`)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default=`1`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)








For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesPartialUpdateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesPartialUpdate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesPartialUpdateRequest {
	return ApiJobTemplatesJobTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesPartialUpdateExecute(r ApiJobTemplatesJobTemplatesPartialUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesPartialUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesReadRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
}

func (r ApiJobTemplatesJobTemplatesReadRequest) Search(search string) ApiJobTemplatesJobTemplatesReadRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesReadExecute(r)
}

/*
 * JobTemplatesJobTemplatesRead  Retrieve a Job Template
 *
Make GET request to this resource to retrieve a single job template
record containing the following fields:

* `id`: Database ID for this job template. (integer)
* `type`: Data type for this job template. (choice)
* `url`: URL for this job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this job template was created. (datetime)
* `modified`: Timestamp when this job template was last modified. (datetime)
* `name`: Name of this job template. (string)
* `description`: Optional description of this job template. (string)
* `job_type`:  (choice)
    - `run`: Run
    - `check`: Check
* `inventory`:  (id)
* `project`:  (id)
* `playbook`:  (string)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string)
* `forks`:  (integer)
* `limit`:  (string)
* `verbosity`:  (choice)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json)
* `job_tags`:  (string)
* `force_handlers`:  (boolean)
* `skip_tags`:  (string)
* `start_at_task`:  (string)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean)
* `organization`: The organization used to determine access to this template. (id)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
* `host_config_key`:  (string)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_diff_mode_on_launch`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `ask_tags_on_launch`:  (boolean)
* `ask_skip_tags_on_launch`:  (boolean)
* `ask_job_type_on_launch`:  (boolean)
* `ask_verbosity_on_launch`:  (boolean)
* `ask_inventory_on_launch`:  (boolean)
* `ask_credential_on_launch`:  (boolean)
* `survey_enabled`:  (boolean)
* `become_enabled`:  (boolean)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean)
* `allow_simultaneous`:  (boolean)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesReadRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesRead(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesReadRequest {
	return ApiJobTemplatesJobTemplatesReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesReadExecute(r ApiJobTemplatesJobTemplatesReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSchedulesCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesSchedulesCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesSchedulesCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesSchedulesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSchedulesCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesSchedulesCreate  Create a Schedule for a Job Template
 *
Make a POST request to this resource with the following schedule
fields to create a new schedule associated with this
job template.


* `rrule`: A value representing the schedules iCal recurrence rule. (string, required)







* `name`: Name of this schedule. (string, required)
* `description`: Optional description of this schedule. (string, default=`""`)
* `extra_data`:  (json, default=`{}`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `scm_branch`:  (string, default=`""`)
* `job_type`:  (choice)
    - `None`: --------- (default)
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string, default=`""`)
* `skip_tags`:  (string, default=`""`)
* `limit`:  (string, default=`""`)
* `diff_mode`:  (boolean, default=`None`)
* `verbosity`:  (choice)
    - `None`: --------- (default)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)

* `enabled`: Enables processing of this schedule. (boolean, default=`True`)











POST requests to this resource must include a proper `rrule` value following
a particular format and conforming to subset of allowed rules.

The following lists the expected format and details of our rrules:

* DTSTART is required and must follow the following format: DTSTART:YYYYMMDDTHHMMSSZ
* DTSTART is expected to be in UTC
* INTERVAL is required
* SECONDLY is not supported
* TZID is not supported
* RRULE must precede the rule statements
* BYDAY is supported but not BYDAY with a numerical prefix
* BYYEARDAY and BYWEEKNO are not supported
* Only one rrule statement per schedule is supported
* COUNT must be < 1000

Here are some example rrules:

    "DTSTART:20500331T055000Z RRULE:FREQ=MINUTELY;INTERVAL=10;COUNT=5"
    "DTSTART:20240331T075000Z RRULE:FREQ=DAILY;INTERVAL=1;COUNT=1"
    "DTSTART:20140331T075000Z RRULE:FREQ=MINUTELY;INTERVAL=1;UNTIL=20230401T075000Z"
    "DTSTART:20140331T075000Z RRULE:FREQ=WEEKLY;INTERVAL=1;BYDAY=MO,WE,FR"
    "DTSTART:20140331T075000Z RRULE:FREQ=WEEKLY;INTERVAL=5;BYDAY=MO"
    "DTSTART:20140331T075000Z RRULE:FREQ=MONTHLY;INTERVAL=1;BYMONTHDAY=6"
    "DTSTART:20140331T075000Z RRULE:FREQ=MONTHLY;INTERVAL=1;BYSETPOS=4;BYDAY=SU"
    "DTSTART:20140331T075000Z RRULE:FREQ=MONTHLY;INTERVAL=1;BYSETPOS=-1;BYDAY=MO,TU,WE,TH,FR"
    "DTSTART:20140331T075000Z RRULE:FREQ=MONTHLY;INTERVAL=1;BYSETPOS=-1;BYDAY=MO,TU,WE,TH,FR,SA,SU"
    "DTSTART:20140331T075000Z RRULE:FREQ=YEARLY;INTERVAL=1;BYMONTH=4;BYMONTHDAY=1"
    "DTSTART:20140331T075000Z RRULE:FREQ=YEARLY;INTERVAL=1;BYSETPOS=-1;BYMONTH=8;BYDAY=SU"
    "DTSTART:20140331T075000Z RRULE:FREQ=WEEKLY;INTERVAL=1;UNTIL=20230401T075000Z;BYDAY=MO,WE,FR"
    "DTSTART:20140331T075000Z RRULE:FREQ=HOURLY;INTERVAL=1;UNTIL=20230610T075000Z"
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSchedulesCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSchedulesCreateRequest {
	return ApiJobTemplatesJobTemplatesSchedulesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesCreateExecute(r ApiJobTemplatesJobTemplatesSchedulesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSchedulesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSchedulesListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesSchedulesListRequest) Page(page int32) ApiJobTemplatesJobTemplatesSchedulesListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesSchedulesListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesSchedulesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesSchedulesListRequest) Search(search string) ApiJobTemplatesJobTemplatesSchedulesListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesSchedulesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSchedulesListExecute(r)
}

/*
 * JobTemplatesJobTemplatesSchedulesList  List Schedules for a Job Template
 *
Make a GET request to this resource to retrieve a list of
schedules associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of schedules
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more schedule records.

## Results

Each schedule data structure includes the following fields:

* `rrule`: A value representing the schedules iCal recurrence rule. (string)
* `id`: Database ID for this schedule. (integer)
* `type`: Data type for this schedule. (choice)
* `url`: URL for this schedule. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this schedule was created. (datetime)
* `modified`: Timestamp when this schedule was last modified. (datetime)
* `name`: Name of this schedule. (string)
* `description`: Optional description of this schedule. (string)
* `extra_data`:  (json)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `scm_branch`:  (string)
* `job_type`:  (choice)
    - `None`: ---------
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string)
* `skip_tags`:  (string)
* `limit`:  (string)
* `diff_mode`:  (boolean)
* `verbosity`:  (choice)
    - `None`: ---------
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `unified_job_template`:  (id)
* `enabled`: Enables processing of this schedule. (boolean)
* `dtstart`: The first occurrence of the schedule occurs on or after this time. (datetime)
* `dtend`: The last occurrence of the schedule occurs before this time, aftewards the schedule expires. (datetime)
* `next_run`: The next time that the scheduled action will run. (datetime)
* `timezone`:  (field)
* `until`:  (field)



## Sorting

To specify that schedules are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSchedulesListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSchedulesListRequest {
	return ApiJobTemplatesJobTemplatesSchedulesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSchedulesListExecute(r ApiJobTemplatesJobTemplatesSchedulesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSchedulesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *InlineObject36
}

func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest) Data(data InlineObject36) ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSliceWorkflowJobsCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesSliceWorkflowJobsCreate  Create a Workflow Job for a Job Template
 *
Make a POST request to this resource with the following workflow job
fields to create a new workflow job associated with this
job template.









* `name`: Name of this workflow job. (string, required)
* `description`: Optional description of this workflow job. (string, default=`""`)









* `workflow_job_template`:  (id, default=``)
* `extra_vars`:  (json, default=``)
* `allow_simultaneous`:  (boolean, default=`False`)

* `is_sliced_job`:  (boolean, default=`False`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `limit`:  (string, default=`""`)
* `scm_branch`:  (string, default=`""`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string, default=`""`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest {
	return ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsCreateExecute(r ApiJobTemplatesJobTemplatesSliceWorkflowJobsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSliceWorkflowJobsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/slice_workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest) Page(page int32) ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest) Search(search string) ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSliceWorkflowJobsListExecute(r)
}

/*
 * JobTemplatesJobTemplatesSliceWorkflowJobsList  List Workflow Jobs for a Job Template
 *
Make a GET request to this resource to retrieve a list of
workflow jobs associated with the selected
job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow jobs
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job records.

## Results

Each workflow job data structure includes the following fields:

* `id`: Database ID for this workflow job. (integer)
* `type`: Data type for this workflow job. (choice)
* `url`: URL for this workflow job. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job was created. (datetime)
* `modified`: Timestamp when this workflow job was last modified. (datetime)
* `name`: Name of this workflow job. (string)
* `description`: Optional description of this workflow job. (string)
* `unified_job_template`:  (id)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `workflow_job_template`:  (id)
* `extra_vars`:  (json)
* `allow_simultaneous`:  (boolean)
* `job_template`: If automatically created for a sliced job run, the job template the workflow job was created from. (id)
* `is_sliced_job`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string)



## Sorting

To specify that workflow jobs are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest {
	return ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSliceWorkflowJobsListExecute(r ApiJobTemplatesJobTemplatesSliceWorkflowJobsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSliceWorkflowJobsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/slice_workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSurveySpecCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesSurveySpecCreateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesSurveySpecCreateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesSurveySpecCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSurveySpecCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesSurveySpecCreate POST requests to this resource should include the full specification for a Job Template's Survey
 *
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSurveySpecCreateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSurveySpecCreateRequest {
	return ApiJobTemplatesJobTemplatesSurveySpecCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecCreateExecute(r ApiJobTemplatesJobTemplatesSurveySpecCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSurveySpecCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
}

func (r ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest) Search(search string) ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSurveySpecDeleteExecute(r)
}

/*
 * JobTemplatesJobTemplatesSurveySpecDelete POST requests to this resource should include the full specification for a Job Template's Survey
 *
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecDelete(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest {
	return ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecDeleteExecute(r ApiJobTemplatesJobTemplatesSurveySpecDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSurveySpecDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesSurveySpecListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesSurveySpecListRequest) Page(page int32) ApiJobTemplatesJobTemplatesSurveySpecListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesSurveySpecListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesSurveySpecListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesSurveySpecListRequest) Search(search string) ApiJobTemplatesJobTemplatesSurveySpecListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesSurveySpecListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesSurveySpecListExecute(r)
}

/*
 * JobTemplatesJobTemplatesSurveySpecList POST requests to this resource should include the full specification for a Job Template's Survey
 *
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesSurveySpecListRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesSurveySpecListRequest {
	return ApiJobTemplatesJobTemplatesSurveySpecListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesSurveySpecListExecute(r ApiJobTemplatesJobTemplatesSurveySpecListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesSurveySpecList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesUpdateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	search     *string
	data       *map[string]interface{}
}

func (r ApiJobTemplatesJobTemplatesUpdateRequest) Search(search string) ApiJobTemplatesJobTemplatesUpdateRequest {
	r.search = &search
	return r
}
func (r ApiJobTemplatesJobTemplatesUpdateRequest) Data(data map[string]interface{}) ApiJobTemplatesJobTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiJobTemplatesJobTemplatesUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesUpdateExecute(r)
}

/*
 * JobTemplatesJobTemplatesUpdate  Update a Job Template
 *
Make a PUT or PATCH request to this resource to update this
job template.  The following fields may be modified:









* `name`: Name of this job template. (string, required)
* `description`: Optional description of this job template. (string, default=`""`)
* `job_type`:  (choice)
    - `run`: Run (default)
    - `check`: Check
* `inventory`:  (id, default=``)
* `project`:  (id, default=``)
* `playbook`:  (string, default=`""`)
* `scm_branch`: Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true. (string, default=`""`)
* `forks`:  (integer, default=`0`)
* `limit`:  (string, default=`""`)
* `verbosity`:  (choice)
    - `0`: 0 (Normal) (default)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `extra_vars`:  (json, default=``)
* `job_tags`:  (string, default=`""`)
* `force_handlers`:  (boolean, default=`False`)
* `skip_tags`:  (string, default=`""`)
* `start_at_task`:  (string, default=`""`)
* `timeout`: The amount of time (in seconds) to run before the task is canceled. (integer, default=`0`)
* `use_fact_cache`: If enabled, Tower will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible. (boolean, default=`False`)





* `host_config_key`:  (string, default=`""`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_diff_mode_on_launch`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `ask_tags_on_launch`:  (boolean, default=`False`)
* `ask_skip_tags_on_launch`:  (boolean, default=`False`)
* `ask_job_type_on_launch`:  (boolean, default=`False`)
* `ask_verbosity_on_launch`:  (boolean, default=`False`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_credential_on_launch`:  (boolean, default=`False`)
* `survey_enabled`:  (boolean, default=`False`)
* `become_enabled`:  (boolean, default=`False`)
* `diff_mode`: If enabled, textual changes made to any templated files on the host are shown in the standard output (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `custom_virtualenv`: Local absolute file path containing a custom Python virtualenv to use (string, default=`""`)
* `job_slice_count`: The number of jobs to slice into at runtime. Will cause the Job Template to launch a workflow if value is greater than 1. (integer, default=`1`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)






For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesUpdateRequest
*/
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesUpdate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesUpdateRequest {
	return ApiJobTemplatesJobTemplatesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesUpdateExecute(r ApiJobTemplatesJobTemplatesUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
}

func (r ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesWebhookKeyCreateExecute(r)
}

/*
 * JobTemplatesJobTemplatesWebhookKeyCreate Method for JobTemplatesJobTemplatesWebhookKeyCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyCreate(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest {
	return ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyCreateExecute(r ApiJobTemplatesJobTemplatesWebhookKeyCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesWebhookKeyCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobTemplatesJobTemplatesWebhookKeyListRequest struct {
	ctx        _context.Context
	ApiService *JobTemplatesApiService
	id         string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiJobTemplatesJobTemplatesWebhookKeyListRequest) Page(page int32) ApiJobTemplatesJobTemplatesWebhookKeyListRequest {
	r.page = &page
	return r
}
func (r ApiJobTemplatesJobTemplatesWebhookKeyListRequest) PageSize(pageSize int32) ApiJobTemplatesJobTemplatesWebhookKeyListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiJobTemplatesJobTemplatesWebhookKeyListRequest) Search(search string) ApiJobTemplatesJobTemplatesWebhookKeyListRequest {
	r.search = &search
	return r
}

func (r ApiJobTemplatesJobTemplatesWebhookKeyListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.JobTemplatesJobTemplatesWebhookKeyListExecute(r)
}

/*
 * JobTemplatesJobTemplatesWebhookKeyList Method for JobTemplatesJobTemplatesWebhookKeyList
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiJobTemplatesJobTemplatesWebhookKeyListRequest
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyList(ctx _context.Context, id string) ApiJobTemplatesJobTemplatesWebhookKeyListRequest {
	return ApiJobTemplatesJobTemplatesWebhookKeyListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *JobTemplatesApiService) JobTemplatesJobTemplatesWebhookKeyListExecute(r ApiJobTemplatesJobTemplatesWebhookKeyListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobTemplatesApiService.JobTemplatesJobTemplatesWebhookKeyList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
