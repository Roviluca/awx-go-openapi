/*
 * Ansible Tower API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// WorkflowJobTemplatesApiService WorkflowJobTemplatesApi service
type WorkflowJobTemplatesApiService service

type ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesAccessListListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesAccessListList  List Users
 * 
Make a GET request to this resource to retrieve the list of
users.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of users
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more user records.  

## Results

Each user data structure includes the following fields:

* `id`: Database ID for this user. (integer)
* `type`: Data type for this user. (choice)
* `url`: URL for this user. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this user was created. (datetime)
* `username`: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string)
* `first_name`:  (string)
* `last_name`:  (string)
* `email`:  (string)
* `is_superuser`: Designates that this user has all permissions without explicitly assigning them. (boolean)
* `is_system_auditor`:  (boolean)

* `ldap_dn`:  (string)
* `last_login`:  (datetime)
* `external_account`: Set if the account is managed by an external service (field)



## Sorting

To specify that users are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=username

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-username

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=username,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesAccessListList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesAccessListListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesAccessListList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/access_list/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamList  List Activity Streams for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
activity streams associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of activity streams
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more activity stream records.  

## Results

Each activity stream data structure includes the following fields:

* `id`: Database ID for this activity stream. (integer)
* `type`: Data type for this activity stream. (choice)
* `url`: URL for this activity stream. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `timestamp`:  (datetime)
* `operation`: The action taken with respect to the given object(s). (choice)
    - `create`: Entity Created
    - `update`: Entity Updated
    - `delete`: Entity Deleted
    - `associate`: Entity Associated with another Entity
    - `disassociate`: Entity was Disassociated with another Entity
* `changes`: A summary of the new and changed values when an object is created, updated, or deleted (json)
* `object1`: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string)
* `object2`: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string)
* `object_association`: When present, shows the field name of the role or relationship that changed. (field)
* `action_node`: The cluster node the activity took place on. (string)
* `object_type`: When present, shows the model on which the role or relationship was defined. (field)



## Sorting

To specify that activity streams are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *InlineObject80
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest) Data(data InlineObject80) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesCopyCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesCopyCreate Copy a Workflow Job Template
 * 
Make a GET request to this resource to determine if the current user has
permission to copy the workflow job template and whether any linked
templates or prompted fields will be ignored due to permissions problems.
The response will include the following fields:

* `can_copy`: Flag indicating whether the active user has permission to make
  a copy of this workflow job template, provides same content as the
  workflow job template detail view summary_fields.user_capabilities.copy
  (boolean, read-only)
* `can_copy_without_user_input`: Flag indicating if the user should be
  prompted for confirmation before the copy is executed (boolean, read-only)
* `templates_unable_to_copy`: List of node ids of nodes that have a related
  job template, project, or inventory that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)
* `inventories_unable_to_copy`: List of node ids of nodes that have a related
  prompted inventory that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)
* `credentials_unable_to_copy`: List of node ids of nodes that have a related
  prompted credential that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)

Make a POST request to this endpoint to save a copy of this
workflow job template. No POST data is accepted for this action.

If successful, the response status code will be 201. The response body will
contain serialized data about the new workflow job template, which will be
similar to the original workflow job template, but with an additional `@`
and a timestamp in the name.

All workflow nodes and connections in the original will also exist in the
copy. The nodes will be missing related resources if the user did not have
access to use them.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesCopyCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesCopyListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesCopyList Copy a Workflow Job Template
 * 
Make a GET request to this resource to determine if the current user has
permission to copy the workflow job template and whether any linked
templates or prompted fields will be ignored due to permissions problems.
The response will include the following fields:

* `can_copy`: Flag indicating whether the active user has permission to make
  a copy of this workflow job template, provides same content as the
  workflow job template detail view summary_fields.user_capabilities.copy
  (boolean, read-only)
* `can_copy_without_user_input`: Flag indicating if the user should be
  prompted for confirmation before the copy is executed (boolean, read-only)
* `templates_unable_to_copy`: List of node ids of nodes that have a related
  job template, project, or inventory that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)
* `inventories_unable_to_copy`: List of node ids of nodes that have a related
  prompted inventory that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)
* `credentials_unable_to_copy`: List of node ids of nodes that have a related
  prompted credential that the current user lacks permission
  to use and will be missing in workflow nodes of the copy (array, read-only)

Make a POST request to this endpoint to save a copy of this
workflow job template. No POST data is accepted for this action.

If successful, the response status code will be 201. The response body will
contain serialized data about the new workflow job template, which will be
similar to the original workflow job template, but with an additional `@`
and a timestamp in the name.

All workflow nodes and connections in the original will also exist in the
copy. The nodes will be missing related resources if the user did not have
access to use them.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesCopyList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	data *InlineObject78
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest) Data(data InlineObject78) ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesCreate  Create a Workflow Job Template
 * 
Make a POST request to this resource with the following workflow job template
fields to create a new workflow job template:









* `name`: Name of this workflow job template. (string, required)
* `description`: Optional description of this workflow job template. (string, default=`""`)




* `extra_vars`:  (json, default=``)
* `organization`: The organization used to determine access to this template. (id, default=``)
* `survey_enabled`:  (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `limit`:  (string, default=`""`)
* `scm_branch`:  (string, default=`""`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCreate(ctx _context.Context) ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesDeleteExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesDelete  Delete a Workflow Job Template
 * 
Make a DELETE request to this resource to delete this workflow job template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesDelete(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesDeleteExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
}


func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesGithubCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesGithubCreate Method for WorkflowJobTemplatesWorkflowJobTemplatesGithubCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGithubCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGithubCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesGithubCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesGithubCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/github/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
}


func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreate Method for WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesGitlabCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/gitlab/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *InlineObject81
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest) Data(data InlineObject81) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreate  Create a Label for a Workflow Job Template
 * 
Make a POST request to this resource with the following label
fields to create a new label associated with this
workflow job template.









* `name`: Name of this label. (string, required)
* `organization`: Organization this label belongs to. (id, required)








# Add Labels for a Workflow Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing label with this workflow job template.

# Remove Labels from this Workflow Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the label from this workflow job template
.




Labels not associated with any other resources are deleted. A label can become disassociated with a resource as a result of 3 events.

1. A label is explicitly disassociated with a related job template
2. A job is deleted with labels
3. A cleanup job deletes a job with labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesLabelsListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesLabelsList  List Labels for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
labels associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of labels
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more label records.  

## Results

Each label data structure includes the following fields:

* `id`: Database ID for this label. (integer)
* `type`: Data type for this label. (choice)
* `url`: URL for this label. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this label was created. (datetime)
* `modified`: Timestamp when this label was last modified. (datetime)
* `name`: Name of this label. (string)
* `organization`: Organization this label belongs to. (id)



## Sorting

To specify that labels are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesLabelsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *InlineObject82
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest) Data(data InlineObject82) ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreate Launch a Workflow Job Template
 * 
Make a GET request to this resource to determine if the workflow_job_template
can be launched and whether any passwords are required to launch the
workflow_job_template. The response will include the following fields:

* `can_start_without_user_input`: Flag indicating if the workflow_job_template
  can be launched without user-input (boolean, read-only)
* `variables_needed_to_start`: Required variable names required to launch the
  workflow_job_template (array, read-only)
* `survey_enabled`: Flag indicating whether the workflow_job_template has an
  enabled survey (boolean, read-only)
* `extra_vars`: Text which is the `extra_vars` field of this workflow_job_template
  (text, read-only)
* `node_templates_missing`: List of node ids of all nodes that have a
  null `unified_job_template`, which will cause their branches to stop
  execution (list, read-only)
* `node_prompts_rejected`: List of node ids of all nodes that have
  specified a field that will be rejected because its  `unified_job_template`
  does not allow prompting for this field, this will not halt execution of
  the branch but the field will be ignored (list, read-only)
* `workflow_job_template_data`: JSON object listing general information of
  this workflow_job_template (JSON object, read-only)

Make a POST request to this resource to launch the workflow_job_template. If any
credential, inventory, project or extra variables (extra_vars) are required, they
must be passed via POST data, with extra_vars given as a YAML or JSON string and
escaped parentheses.

If successful, the response status code will be 201.  If any required passwords
are not provided, a 400 status code will be returned.  If the workflow job cannot
be launched, a 405 status code will be returned. If the provided credential or
inventory are not allowed to be used by the user, then a 403 status code will
be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesLaunchReadExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesLaunchRead Launch a Workflow Job Template
 * 
Make a GET request to this resource to determine if the workflow_job_template
can be launched and whether any passwords are required to launch the
workflow_job_template. The response will include the following fields:

* `can_start_without_user_input`: Flag indicating if the workflow_job_template
  can be launched without user-input (boolean, read-only)
* `variables_needed_to_start`: Required variable names required to launch the
  workflow_job_template (array, read-only)
* `survey_enabled`: Flag indicating whether the workflow_job_template has an
  enabled survey (boolean, read-only)
* `extra_vars`: Text which is the `extra_vars` field of this workflow_job_template
  (text, read-only)
* `node_templates_missing`: List of node ids of all nodes that have a
  null `unified_job_template`, which will cause their branches to stop
  execution (list, read-only)
* `node_prompts_rejected`: List of node ids of all nodes that have
  specified a field that will be rejected because its  `unified_job_template`
  does not allow prompting for this field, this will not halt execution of
  the branch but the field will be ignored (list, read-only)
* `workflow_job_template_data`: JSON object listing general information of
  this workflow_job_template (JSON object, read-only)

Make a POST request to this resource to launch the workflow_job_template. If any
credential, inventory, project or extra variables (extra_vars) are required, they
must be passed via POST data, with extra_vars given as a YAML or JSON string and
escaped parentheses.

If successful, the response status code will be 201.  If any required passwords
are not provided, a 400 status code will be returned.  If the workflow job cannot
be launched, a 405 status code will be returned. If the provided credential or
inventory are not allowed to be used by the user, then a 403 status code will
be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchRead(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchReadExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesLaunchRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesList  List Workflow Job Templates
 * 
Make a GET request to this resource to retrieve the list of
workflow job templates.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow job templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job template records.  

## Results

Each workflow job template data structure includes the following fields:

* `id`: Database ID for this workflow job template. (integer)
* `type`: Data type for this workflow job template. (choice)
* `url`: URL for this workflow job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job template was created. (datetime)
* `modified`: Timestamp when this workflow job template was last modified. (datetime)
* `name`: Name of this workflow job template. (string)
* `description`: Optional description of this workflow job template. (string)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
    - `ok`: OK
    - `missing`: Missing
    - `none`: No External Source
    - `updating`: Updating
* `extra_vars`:  (json)
* `organization`: The organization used to determine access to this template. (id)
* `survey_enabled`:  (boolean)
* `allow_simultaneous`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `ask_inventory_on_launch`:  (boolean)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)



## Sorting

To specify that workflow job templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesList(ctx _context.Context) ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreate  Create a Notification Template for a Workflow Job Template
 * 
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
workflow job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Workflow Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this workflow job template.

# Remove Notification Templates from this Workflow Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this workflow job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsList  List Notification Templates for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.  

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *InlineObject83
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest) Data(data InlineObject83) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreate  Create a Notification Template for a Workflow Job Template
 * 
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
workflow job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Workflow Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this workflow job template.

# Remove Notification Templates from this Workflow Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this workflow job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorList  List Notification Templates for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.  

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreate  Create a Notification Template for a Workflow Job Template
 * 
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
workflow job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Workflow Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this workflow job template.

# Remove Notification Templates from this Workflow Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this workflow job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedList  List Notification Templates for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.  

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *InlineObject84
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest) Data(data InlineObject84) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreate  Create a Notification Template for a Workflow Job Template
 * 
Make a POST request to this resource with the following notification template
fields to create a new notification template associated with this
workflow job template.









* `name`: Name of this notification template. (string, required)
* `description`: Optional description of this notification template. (string, default=`""`)
* `organization`:  (id, required)
* `notification_type`:  (choice, required)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json, default=`{}`)
* `messages`: Optional custom messages for notification template. (json, default=`{&#39;started&#39;: None, &#39;success&#39;: None, &#39;error&#39;: None, &#39;workflow_approval&#39;: None}`)








# Add Notification Templates for a Workflow Job Template:

Make a POST request to this resource with only an `id` field to associate an
existing notification template with this workflow job template.

# Remove Notification Templates from this Workflow Job Template:

Make a POST request to this resource with `id` and `disassociate` fields to
remove the notification template from this workflow job template
 without deleting the notification template.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessList  List Notification Templates for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
notification templates associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of notification templates
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more notification template records.  

## Results

Each notification template data structure includes the following fields:

* `id`: Database ID for this notification template. (integer)
* `type`: Data type for this notification template. (choice)
* `url`: URL for this notification template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this notification template was created. (datetime)
* `modified`: Timestamp when this notification template was last modified. (datetime)
* `name`: Name of this notification template. (string)
* `description`: Optional description of this notification template. (string)
* `organization`:  (id)
* `notification_type`:  (choice)
    - `email`: Email
    - `grafana`: Grafana
    - `irc`: IRC
    - `mattermost`: Mattermost
    - `pagerduty`: Pagerduty
    - `rocketchat`: Rocket.Chat
    - `slack`: Slack
    - `twilio`: Twilio
    - `webhook`: Webhook
* `notification_configuration`:  (json)
* `messages`: Optional custom messages for notification template. (json)



## Sorting

To specify that notification templates are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesList  List Roles for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
roles associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of roles
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more role records.  

## Results

Each role data structure includes the following fields:

* `id`: Database ID for this role. (integer)
* `type`: Data type for this role. (choice)
* `url`: URL for this role. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `name`: Name of this role. (field)
* `description`: Optional description of this role. (field)



## Sorting

To specify that roles are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/object_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest {
	r.search = &search
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdate  Update a Workflow Job Template
 * 
Make a PUT or PATCH request to this resource to update this
workflow job template.  The following fields may be modified:









* `name`: Name of this workflow job template. (string, required)
* `description`: Optional description of this workflow job template. (string, default=`""`)




* `extra_vars`:  (json, default=``)
* `organization`: The organization used to determine access to this template. (id, default=``)
* `survey_enabled`:  (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `limit`:  (string, default=`""`)
* `scm_branch`:  (string, default=`""`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)








For a PATCH request, include only the fields that are being modified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesReadExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesRead  Retrieve a Workflow Job Template
 * 
Make GET request to this resource to retrieve a single workflow job template
record containing the following fields:

* `id`: Database ID for this workflow job template. (integer)
* `type`: Data type for this workflow job template. (choice)
* `url`: URL for this workflow job template. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job template was created. (datetime)
* `modified`: Timestamp when this workflow job template was last modified. (datetime)
* `name`: Name of this workflow job template. (string)
* `description`: Optional description of this workflow job template. (string)
* `last_job_run`:  (datetime)
* `last_job_failed`:  (boolean)
* `next_job_run`:  (datetime)
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
    - `never updated`: Never Updated
    - `ok`: OK
    - `missing`: Missing
    - `none`: No External Source
    - `updating`: Updating
* `extra_vars`:  (json)
* `organization`: The organization used to determine access to this template. (id)
* `survey_enabled`:  (boolean)
* `allow_simultaneous`:  (boolean)
* `ask_variables_on_launch`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `ask_inventory_on_launch`:  (boolean)
* `ask_scm_branch_on_launch`:  (boolean)
* `ask_limit_on_launch`:  (boolean)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesRead(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesReadExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreate  Create a Schedule for a Workflow Job Template
 * 
Make a POST request to this resource with the following schedule
fields to create a new schedule associated with this
workflow job template.


* `rrule`: A value representing the schedules iCal recurrence rule. (string, required)







* `name`: Name of this schedule. (string, required)
* `description`: Optional description of this schedule. (string, default=`""`)
* `extra_data`:  (json, default=`{}`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `scm_branch`:  (string, default=`""`)
* `job_type`:  (choice)
    - `None`: --------- (default)
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string, default=`""`)
* `skip_tags`:  (string, default=`""`)
* `limit`:  (string, default=`""`)
* `diff_mode`:  (boolean, default=`None`)
* `verbosity`:  (choice)
    - `None`: --------- (default)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)

* `enabled`: Enables processing of this schedule. (boolean, default=`True`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesSchedulesListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesSchedulesList  List Schedules for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
schedules associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of schedules
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more schedule records.  

## Results

Each schedule data structure includes the following fields:

* `rrule`: A value representing the schedules iCal recurrence rule. (string)
* `id`: Database ID for this schedule. (integer)
* `type`: Data type for this schedule. (choice)
* `url`: URL for this schedule. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this schedule was created. (datetime)
* `modified`: Timestamp when this schedule was last modified. (datetime)
* `name`: Name of this schedule. (string)
* `description`: Optional description of this schedule. (string)
* `extra_data`:  (json)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `scm_branch`:  (string)
* `job_type`:  (choice)
    - `None`: ---------
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string)
* `skip_tags`:  (string)
* `limit`:  (string)
* `diff_mode`:  (boolean)
* `verbosity`:  (choice)
    - `None`: ---------
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `unified_job_template`:  (id)
* `enabled`: Enables processing of this schedule. (boolean)
* `dtstart`: The first occurrence of the schedule occurs on or after this time. (datetime)
* `dtend`: The last occurrence of the schedule occurs before this time, aftewards the schedule expires. (datetime)
* `next_run`: The next time that the scheduled action will run. (datetime)
* `timezone`:  (field)
* `until`:  (field)



## Sorting

To specify that schedules are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesSchedulesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreate POST requests to this resource should include the full specification for a Workflow Job Template's Survey
 * 
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the workflow job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDelete POST requests to this resource should include the full specification for a Workflow Job Template's Survey
 * 
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the workflow job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDelete(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecList POST requests to this resource should include the full specification for a Workflow Job Template's Survey
 * 
Here is an example survey specification:

    {
        "name": "Simple Survey",
        "description": "Description of the simple survey",
        "spec": [
            {
        	"type": "text",
        	"question_name": "example question",
        	"question_description": "What is your favorite color?",
        	"variable": "favorite_color",
        	"required": false,
        	"default": "blue"
            }
        ]
    }

`name` and `description` are required elements at the beginning of the survey specification. `spec` must be a
list of survey items.

Within each survey item `type` must be one of:

* text: For survey questions expecting a textual answer
* password: For survey questions expecting a password or other sensitive information
* integer: For survey questions expecting a whole number answer
* float: For survey questions expecting a decimal number
* multiplechoice: For survey questions where one option from a list is required
* multiselect: For survey questions where multiple items from a presented list can be selected

Each item must contain a `question_name` and `question_description` field that describes the survey question itself.
The `variable` elements of each survey items represents the key that will be given to the playbook when the workflow job template
is launched.  It will contain the value as a result of the survey.

Here is a more comprehensive example showing the various question types and their acceptable parameters:

    {
        "name": "Simple",
        "description": "Description",
        "spec": [
            {
        	"type": "text",
        	"question_name": "cantbeshort",
        	"question_description": "What is a long answer",
        	"variable": "long_answer",
        	"choices": "",
        	"min": 5,
        	"max": "",
        	"required": false,
        	"default": "Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat"
            },
            {
        	"type": "text",
        	"question_name": "cantbelong",
        	"question_description": "What is a short answer",
        	"variable": "short_answer",
        	"choices": "",
        	"min": "",
        	"max": 7,
        	"required": false,
        	"default": "leeloo"
            },
            {
        	"type": "text",
        	"question_name": "reqd",
        	"question_description": "I should be required",
        	"variable": "reqd_answer",
        	"choices": "",
        	"min": "",
        	"max": "",
        	"required": true,
        	"default": "NOT OPTIONAL"
            },
            {
        	"type": "multiplechoice",
        	"question_name": "achoice",
        	"question_description": "Need one of these",
        	"variable": "single_choice",
        	"choices": ["one", "two"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one"
            },
            {
        	"type": "multiselect",
        	"question_name": "mchoice",
        	"question_description": "Can have multiples of these",
        	"variable": "multi_choice",
        	"choices": ["one", "two", "three"],
        	"min": "",
        	"max": "",
        	"required": false,
        	"default": "one\nthree"
            },
            {
                "type": "integer",
                "question_name": "integerchoice",
                "question_description": "I need an int here",
                "variable": "int_answer",
                "choices": "",
                "min": 1,
                "max": 5,
                "required": false,
                "default": ""
            },
            {
                "type": "float",
                "question_name": "float",
                "question_description": "I need a float here",
                "variable": "float_answer",
                "choices": "",
                "min": 2,
                "max": 5,
                "required": false,
                "default": ""
            }
        ]
    }
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	search *string
	data *InlineObject79
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest {
	r.search = &search
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest) Data(data InlineObject79) ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesUpdateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesUpdate  Update a Workflow Job Template
 * 
Make a PUT or PATCH request to this resource to update this
workflow job template.  The following fields may be modified:









* `name`: Name of this workflow job template. (string, required)
* `description`: Optional description of this workflow job template. (string, default=`""`)




* `extra_vars`:  (json, default=``)
* `organization`: The organization used to determine access to this template. (id, default=``)
* `survey_enabled`:  (boolean, default=`False`)
* `allow_simultaneous`:  (boolean, default=`False`)
* `ask_variables_on_launch`:  (boolean, default=`False`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `limit`:  (string, default=`""`)
* `scm_branch`:  (string, default=`""`)
* `ask_inventory_on_launch`:  (boolean, default=`False`)
* `ask_scm_branch_on_launch`:  (boolean, default=`False`)
* `ask_limit_on_launch`:  (boolean, default=`False`)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id, default=``)






For a PUT request, include **all** fields in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesUpdate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesUpdateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
}


func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreate Method for WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyList Method for WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyList
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsList  List Workflow Jobs for a Workflow Job Template
 * 
Make a GET request to this resource to retrieve a list of
workflow jobs associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow jobs
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job records.  

## Results

Each workflow job data structure includes the following fields:

* `id`: Database ID for this workflow job. (integer)
* `type`: Data type for this workflow job. (choice)
* `url`: URL for this workflow job. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job was created. (datetime)
* `modified`: Timestamp when this workflow job was last modified. (datetime)
* `name`: Name of this workflow job. (string)
* `description`: Optional description of this workflow job. (string)
* `unified_job_template`:  (id)
* `launch_type`:  (choice)
    - `manual`: Manual
    - `relaunch`: Relaunch
    - `callback`: Callback
    - `scheduled`: Scheduled
    - `dependency`: Dependency
    - `workflow`: Workflow
    - `webhook`: Webhook
    - `sync`: Sync
    - `scm`: SCM Update
* `status`:  (choice)
    - `new`: New
    - `pending`: Pending
    - `waiting`: Waiting
    - `running`: Running
    - `successful`: Successful
    - `failed`: Failed
    - `error`: Error
    - `canceled`: Canceled
* `failed`:  (boolean)
* `started`: The date and time the job was queued for starting. (datetime)
* `finished`: The date and time the job finished execution. (datetime)
* `canceled_on`: The date and time when the cancel request was sent. (datetime)
* `elapsed`: Elapsed time in seconds that the job ran. (decimal)
* `job_explanation`: A status field to indicate the state of the job if it wasn&#39;t able to run and capture stdout (string)
* `workflow_job_template`:  (id)
* `extra_vars`:  (json)
* `allow_simultaneous`:  (boolean)
* `job_template`: If automatically created for a sliced job run, the job template the workflow job was created from. (id)
* `is_sliced_job`:  (boolean)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `limit`:  (string)
* `scm_branch`:  (string)
* `webhook_service`: Service that webhook requests will be accepted from (choice)
    - `""`: ---------
    - `github`: GitHub
    - `gitlab`: GitLab
* `webhook_credential`: Personal Access Token for posting back the status to the service API (id)
* `webhook_guid`: Unique identifier of the event that triggered this webhook (string)



## Sorting

To specify that workflow jobs are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	data *map[string]interface{}
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest) Data(data map[string]interface{}) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest {
	r.data = &data
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreate  Workflow Job Template Workflow Node List
 * 
Workflow nodes reference templates to execute and define the ordering
in which to execute them. After a job in this workflow finishes,
the subsequent actions are to:

 - run nodes contained in "failure_nodes" or "always_nodes" if job failed
 - run nodes contained in "success_nodes" or "always_nodes" if job succeeded

The workflow job is marked as `successful` if all of the jobs running as
a part of the workflow job have completed, and the workflow job has not
been canceled. Even if a job within the workflow has failed, the workflow
job will not be marked as failed.




# Create a Workflow Job Template Node for a Workflow Job Template:

Make a POST request to this resource with the following workflow job template node
fields to create a new workflow job template node associated with this
workflow job template.









* `extra_data`:  (json, default=`{}`)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id, default=``)
* `scm_branch`:  (string, default=`""`)
* `job_type`:  (choice)
    - `None`: --------- (default)
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string, default=`""`)
* `skip_tags`:  (string, default=`""`)
* `limit`:  (string, default=`""`)
* `diff_mode`:  (boolean, default=`None`)
* `verbosity`:  (choice)
    - `None`: --------- (default)
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)

* `unified_job_template`:  (id, default=``)



* `all_parents_must_converge`: If enabled then the node will only run if all of the parent nodes have met the criteria to reach this node (boolean, default=`False`)
* `identifier`: An identifier for this node that is unique within its workflow. It is copied to workflow job nodes corresponding to this node. (string, default=`"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreate(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/workflow_nodes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest struct {
	ctx _context.Context
	ApiService *WorkflowJobTemplatesApiService
	id string
	page *int32
	pageSize *int32
	search *string
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest) Page(page int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest {
	r.page = &page
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest) PageSize(pageSize int32) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest) Search(search string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest {
	r.search = &search
	return r
}

func (r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListExecute(r)
}

/*
 * WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesList  Workflow Job Template Workflow Node List
 * 
Workflow nodes reference templates to execute and define the ordering
in which to execute them. After a job in this workflow finishes,
the subsequent actions are to:

 - run nodes contained in "failure_nodes" or "always_nodes" if job failed
 - run nodes contained in "success_nodes" or "always_nodes" if job succeeded

The workflow job is marked as `successful` if all of the jobs running as
a part of the workflow job have completed, and the workflow job has not
been canceled. Even if a job within the workflow has failed, the workflow
job will not be marked as failed.


# List Workflow Job Template Nodes for a Workflow Job Template:

Make a GET request to this resource to retrieve a list of
workflow job template nodes associated with the selected
workflow job template.

The resulting data structure contains:

    {
        "count": 99,
        "next": null,
        "previous": null,
        "results": [
            ...
        ]
    }

The `count` field indicates the total number of workflow job template nodes
found for the given query.  The `next` and `previous` fields provides links to
additional results if there are more than will fit on a single page.  The
`results` list contains zero or more workflow job template node records.  

## Results

Each workflow job template node data structure includes the following fields:

* `id`: Database ID for this workflow job template node. (integer)
* `type`: Data type for this workflow job template node. (choice)
* `url`: URL for this workflow job template node. (string)
* `related`: Data structure with URLs of related resources. (object)
* `summary_fields`: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object)
* `created`: Timestamp when this workflow job template node was created. (datetime)
* `modified`: Timestamp when this workflow job template node was last modified. (datetime)
* `extra_data`:  (json)
* `inventory`: Inventory applied as a prompt, assuming job template prompts for inventory (id)
* `scm_branch`:  (string)
* `job_type`:  (choice)
    - `None`: ---------
    - `""`: ---------
    - `run`: Run
    - `check`: Check
* `job_tags`:  (string)
* `skip_tags`:  (string)
* `limit`:  (string)
* `diff_mode`:  (boolean)
* `verbosity`:  (choice)
    - `None`: ---------
    - `0`: 0 (Normal)
    - `1`: 1 (Verbose)
    - `2`: 2 (More Verbose)
    - `3`: 3 (Debug)
    - `4`: 4 (Connection Debug)
    - `5`: 5 (WinRM Debug)
* `workflow_job_template`:  (id)
* `unified_job_template`:  (id)
* `success_nodes`:  (field)
* `failure_nodes`:  (field)
* `always_nodes`:  (field)
* `all_parents_must_converge`: If enabled then the node will only run if all of the parent nodes have met the criteria to reach this node (boolean)
* `identifier`: An identifier for this node that is unique within its workflow. It is copied to workflow job nodes corresponding to this node. (string)



## Sorting

To specify that workflow job template nodes are returned in a particular
order, use the `order_by` query string parameter on the GET request.

    ?order_by=name

Prefix the field name with a dash `-` to sort in reverse:

    ?order_by=-name

Multiple sorting fields may be specified by separating the field names with a
comma `,`:

    ?order_by=name,some_other_field

## Pagination

Use the `page_size` query string parameter to change the number of results
returned for each request.  Use the `page` query string parameter to retrieve
a particular page of results.

    ?page_size=100&page=2

The `previous` and `next` links returned with the results will set these query
string parameters automatically.

## Searching

Use the `search` query string parameter to perform a case-insensitive search
within all designated text fields of a model.

    ?search=findme

(_Added in Ansible Tower 3.1.0_) Search across related fields:

    ?related__search=findme
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesList(ctx _context.Context, id string) ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest {
	return ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListExecute(r ApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowJobTemplatesApiService.WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/workflow_job_templates/{id}/workflow_nodes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
